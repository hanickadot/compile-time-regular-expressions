/*

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

    1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

    2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

    3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

    4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

    5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

    6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

    7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

    8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

    9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

    END OF TERMS AND CONDITIONS

    APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

    Copyright [yyyy] [name of copyright owner]

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.


--- LLVM Exceptions to the Apache 2.0 License ----

As an exception, if, as a result of your compiling your source code, portions
of this Software are embedded into an Object form of such source code, you
may redistribute such embedded portions in such Object form without complying
with the conditions of Sections 4(a), 4(b) and 4(d) of the License.

In addition, if you combine or link compiled forms of this Software with
software that is licensed under the GPLv2 ("Combined Software") and if a
court of competent jurisdiction determines that the patent provision (Section
3), the indemnity provision (Section 9) or other Section of the License
conflicts with the conditions of the GPLv2, you may retroactively and
prospectively choose to deem waived or otherwise exclude such Section(s) of
the License, but only in their entirety and only with respect to the Combined
Software.

*/

#ifndef CTRE_V2__CTRE__HPP
#define CTRE_V2__CTRE__HPP

#ifndef CTRE_V2__CTRE__LITERALS__HPP
#define CTRE_V2__CTRE__LITERALS__HPP

#ifndef CTRE_V2__CTLL__HPP
#define CTRE_V2__CTLL__HPP

#ifndef CTLL__PARSER__HPP
#define CTLL__PARSER__HPP

#ifndef CTLL__FIXED_STRING__GPP
#define CTLL__FIXED_STRING__GPP

#include <utility>
#include <cstddef>
#include <string_view>

namespace ctll {

struct length_value_t {
	uint32_t value;
	uint8_t length;
};

constexpr length_value_t length_and_value_of_utf8_code_point(uint8_t first_unit) noexcept {
	if ((first_unit & 0b1000'0000) == 0b0000'0000) return {static_cast<uint32_t>(first_unit), 1};
	else if ((first_unit & 0b1110'0000) == 0b1100'0000) return {static_cast<uint32_t>(first_unit & 0b0001'1111), 2};
	else if ((first_unit & 0b1111'0000) == 0b1110'0000) return {static_cast<uint32_t>(first_unit & 0b0000'1111), 3};
	else if ((first_unit & 0b1111'1000) == 0b1111'0000) return {static_cast<uint32_t>(first_unit & 0b0000'0111), 4};
	else if ((first_unit & 0b1111'1100) == 0b1111'1000) return {static_cast<uint32_t>(first_unit & 0b0000'0011), 5};
	else if ((first_unit & 0b1111'1100) == 0b1111'1100) return {static_cast<uint32_t>(first_unit & 0b0000'0001), 6};
	else return {0, 0};
}

constexpr char32_t value_of_trailing_utf8_code_point(uint8_t unit, bool & correct) noexcept {
	if ((unit & 0b1100'0000) == 0b1000'0000) return unit & 0b0011'1111;
	else {
		correct = false;
		return 0;
	}
}

constexpr length_value_t length_and_value_of_utf16_code_point(uint16_t first_unit) noexcept {
	if ((first_unit & 0b1111110000000000) == 0b1101'1000'0000'0000) return {static_cast<uint32_t>(first_unit & 0b0000001111111111), 2};
	else return {first_unit, 1};
}

template <size_t N> class fixed_string {
private:
	char32_t content[N] = {};
	size_t real_size{0};
	bool correct_flag{true};
public:
	template <typename T> constexpr fixed_string(const T (&input)[N]) noexcept {
		if constexpr (std::is_same_v<T, char>) {
			#if CTRE_STRING_IS_UTF8
				size_t out{0};
				for (size_t i{0}; i < N; ++i) {
					if ((i == (N-1)) && (input[i] == 0)) break;
					length_value_t info = length_and_value_of_utf8_code_point(input[i]);
					switch (info.length) {
						case 6:
							if (++i < N) info.value = (info.value << 6) | value_of_trailing_utf8_code_point(input[i], correct_flag);
							[[fallthrough]];
						case 5:
							if (++i < N) info.value = (info.value << 6) | value_of_trailing_utf8_code_point(input[i], correct_flag);
							[[fallthrough]];
						case 4:
							if (++i < N) info.value = (info.value << 6) | value_of_trailing_utf8_code_point(input[i], correct_flag);
							[[fallthrough]];
						case 3:
							if (++i < N) info.value = (info.value << 6) | value_of_trailing_utf8_code_point(input[i], correct_flag);
							[[fallthrough]];
						case 2:
							if (++i < N) info.value = (info.value << 6) | value_of_trailing_utf8_code_point(input[i], correct_flag);
							[[fallthrough]];
						case 1:
							content[out++] = static_cast<char32_t>(info.value);
							real_size++;
							break;
						default:
							correct_flag = false;
							return;
					}
				}
			#else
				for (size_t i{0}; i < N; ++i) {
					content[i] = static_cast<uint8_t>(input[i]);
					if ((i == (N-1)) && (input[i] == 0)) break;
					real_size++;
				}
			#endif
		#if __cpp_char8_t
		} else if constexpr (std::is_same_v<T, char8_t>) {
			size_t out{0};
			for (size_t i{0}; i < N; ++i) {
				if ((i == (N-1)) && (input[i] == 0)) break;
				length_value_t info = length_and_value_of_utf8_code_point(input[i]);
				switch (info.length) {
					case 6:
						if (++i < N) info.value = (info.value << 6) | value_of_trailing_utf8_code_point(input[i], correct_flag);
						[[fallthrough]];
					case 5:
						if (++i < N) info.value = (info.value << 6) | value_of_trailing_utf8_code_point(input[i], correct_flag);
						[[fallthrough]];
					case 4:
						if (++i < N) info.value = (info.value << 6) | value_of_trailing_utf8_code_point(input[i], correct_flag);
						[[fallthrough]];
					case 3:
						if (++i < N) info.value = (info.value << 6) | value_of_trailing_utf8_code_point(input[i], correct_flag);
						[[fallthrough]];
					case 2:
						if (++i < N) info.value = (info.value << 6) | value_of_trailing_utf8_code_point(input[i], correct_flag);
						[[fallthrough]];
					case 1:
						content[out++] = static_cast<char32_t>(info.value);
						real_size++;
						break;
					default:
						correct_flag = false;
						return;
				}
			}
		#endif
		} else if constexpr (std::is_same_v<T, char16_t>) {
			size_t out{0};
			for (size_t i{0}; i < N; ++i) {
				length_value_t info = length_and_value_of_utf16_code_point(input[i]);
				if (info.length == 2) {
					if (++i < N) {
						if ((input[i] & 0b1111'1100'0000'0000) == 0b1101'1100'0000'0000) {
							content[out++] = (info.value << 10) | (input[i] & 0b0000'0011'1111'1111);
						} else {
							correct_flag = false;
							break;
						}
					}
				} else {
					if ((i == (N-1)) && (input[i] == 0)) break;
					content[out++] = info.value;
				}
			}
			real_size = out;
		} else if constexpr (std::is_same_v<T, wchar_t> || std::is_same_v<T, char32_t>) {
			for (size_t i{0}; i < N; ++i) {
				content[i] = input[i];
				if ((i == (N-1)) && (input[i] == 0)) break;
				real_size++;
			}
		}
	}
	constexpr fixed_string(const fixed_string & other) noexcept {
		for (size_t i{0}; i < N; ++i) {
			content[i] = other.content[i];
		}
		real_size = other.real_size;
		correct_flag = other.correct_flag;
	}
	constexpr bool correct() const noexcept {
		return correct_flag;
	}
	constexpr size_t size() const noexcept {
		return real_size;
	}
	constexpr const char32_t * begin() const noexcept {
		return content;
	}
	constexpr const char32_t * end() const noexcept {
		return content + size();
	}
	constexpr char32_t operator[](size_t i) const noexcept {
		return content[i];
	}
	template <size_t M> constexpr bool is_same_as(const fixed_string<M> & rhs) const noexcept {
		if (real_size != rhs.size()) return false;
		for (size_t i{0}; i != real_size; ++i) {
			if (content[i] != rhs[i]) return false;
		}
		return true;
	}
};

template <> class fixed_string<0> {
	static constexpr char32_t __empty[1] = {0};
public:
	template <typename T> constexpr fixed_string(const T *) noexcept {
		
	}
	constexpr fixed_string(std::initializer_list<char32_t>) noexcept {
		
	}
	constexpr fixed_string(const fixed_string &) noexcept {
			
	}
	constexpr bool correct() const noexcept {
		return true;
	}
	constexpr size_t size() const noexcept {
		return 0;
	}
	constexpr const char32_t * begin() const noexcept {
		return __empty;
	}
	constexpr const char32_t * end() const noexcept {
		return __empty + size();
	}
	constexpr char32_t operator[](size_t) const noexcept {
		return 0;
	}
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<N>;
template <size_t N> fixed_string(fixed_string<N>) -> fixed_string<N>;

template <typename T, size_t N> class basic_fixed_string: public fixed_string<N> {
	using parent = fixed_string<N>;
public:
	template <typename... Args> constexpr basic_fixed_string(Args && ... args) noexcept: parent(std::forward<Args>(args)...) { }
};

template <typename CharT, size_t N> basic_fixed_string(const CharT (&)[N]) -> basic_fixed_string<CharT, N>;
template <typename CharT, size_t N> basic_fixed_string(basic_fixed_string<CharT, N>) -> basic_fixed_string<CharT, N>;

}

#endif

#ifndef CTLL__TYPE_STACK__HPP
#define CTLL__TYPE_STACK__HPP

#ifndef CTLL__UTILITIES__HPP
#define CTLL__UTILITIES__HPP

#include <type_traits>

#ifdef _MSC_VER
#define CTLL_FORCE_INLINE __forceinline
#else
#define CTLL_FORCE_INLINE __attribute__((always_inline))
#endif

namespace ctll {
	
template <bool> struct conditional_helper;
	
template <> struct conditional_helper<true> {
	template <typename A, typename> using type = A;
};

template <> struct conditional_helper<false> {
	template <typename, typename B> using type = B;
};

template <bool V, typename A, typename B> using conditional = typename conditional_helper<V>::template type<A,B>;
	
}

#endif

namespace ctll {

template <typename... Ts> struct list { };
	
struct _nothing { };

using empty_list = list<>;

// calculate size of list content
template <typename... Ts> constexpr auto size(list<Ts...>) noexcept { return sizeof...(Ts); }

	
// check if the list is empty
template <typename... Ts> constexpr bool empty(list<Ts...>) noexcept { return false; }
constexpr bool empty(empty_list) { return true; }

// concat two lists together left to right
template <typename... As, typename... Bs> constexpr auto concat(list<As...>, list<Bs...>) noexcept -> list<As..., Bs...> { return {}; }

// push something to the front of a list
template <typename T, typename... As> constexpr auto push_front(T, list<As...>) noexcept -> list<T, As...> { return {}; }

// pop element from the front of a list
template <typename T, typename... As> constexpr auto pop_front(list<T, As...>) noexcept -> list<As...> { return {}; }
constexpr auto pop_front(empty_list) -> empty_list;

// pop element from the front of a list and return new typelist too
template <typename Front, typename List> struct list_pop_pair {
	Front front{};
	List list{};
	constexpr list_pop_pair() = default;
};

template <typename Head, typename... As, typename T = _nothing> constexpr auto pop_and_get_front(list<Head, As...>, T = T()) noexcept -> list_pop_pair<Head, list<As...>> { return {}; }
template <typename T = _nothing> constexpr auto pop_and_get_front(empty_list, T = T()) noexcept -> list_pop_pair<T, empty_list> { return {}; }

// return front of the list
template <typename Head, typename... As, typename T = _nothing> constexpr auto front(list<Head, As...>, T = T()) noexcept -> Head { return {}; }
template <typename T = _nothing> constexpr auto front(empty_list, T = T()) noexcept -> T { return {}; }

}

#endif

#ifndef CTLL__GRAMMARS__HPP
#define CTLL__GRAMMARS__HPP

namespace ctll {

// terminal type representing symbol / character of any type
template <auto v> struct term {
	static constexpr auto value = v;
};

// epsilon = nothing on input tape
// also used as an command for parsing means "do nothing"
struct epsilon {
	static constexpr auto value = '-';
};

// empty_stack_symbol = nothing on stack
struct empty_stack_symbol {};

// push<T...> is alias to list<T...>
template <typename... Ts> using push = list<Ts...>;

// accept/reject type for controlling output of LL1 machine
struct accept { constexpr explicit operator bool() noexcept { return true; } };
struct reject { constexpr explicit operator bool() noexcept { return false; } };

// action type, every action item in grammar must inherit from
struct action { 
	struct action_tag { };
};

// move one character forward and pop it from stack command
struct pop_input {
	struct pop_input_tag { };
};

// additional overloads for type list
template <typename... Ts> constexpr auto push_front(pop_input, list<Ts...>) -> list<Ts...> { return {}; }

template <typename... Ts> constexpr auto push_front(epsilon, list<Ts...>) -> list<Ts...> { return {}; }

template <typename... As, typename... Bs> constexpr auto push_front(list<As...>, list<Bs...>) -> list<As..., Bs...> { return {}; }

template <typename T, typename... As> constexpr auto pop_front_and_push_front(T item, list<As...> l) {
	return push_front(item, pop_front(l));
}

// SPECIAL matching types for nicer grammars

// match any term
struct anything {
	constexpr inline anything() noexcept { };
	template <auto V> constexpr anything(term<V>) noexcept;
};

// match range of term A-B
template <auto A, decltype(A) B> struct range {
	constexpr inline range() noexcept { };
	//template <auto V> constexpr range(term<V>) noexcept requires (A <= V) && (V <= B);
	template <auto V, typename = std::enable_if_t<(A <= V) && (V <= B)>> constexpr inline range(term<V>) noexcept;
};

// match terms defined in set
template <auto... Def> struct set {
	constexpr inline set() noexcept { };
	//template <auto V> constexpr set(term<V>) noexcept requires ((Def == V) || ... || false);
	template <auto V, typename = std::enable_if_t<((Def == V) || ... || false)>> constexpr inline set(term<V>) noexcept;
};

// match terms not defined in set
template <auto... Def> struct neg_set {
	constexpr inline neg_set() noexcept { };
	//template <auto V> constexpr set(term<V>) noexcept requires ((Def == V) || ... || false);
	template <auto V, typename = std::enable_if_t<((Def != V) && ... && true)>> constexpr inline neg_set(term<V>) noexcept;
};

// AUGMENTED grammar which completes user-defined grammar for all other cases
template <typename Grammar> struct augment_grammar: public Grammar {
	// start nonterminal is defined in parent type
	using typename Grammar::_start; 
	
	// grammar rules are inherited from Grammar parent type
	using Grammar::rule; 
	
	// term on stack and on input means pop_input;
	template <auto A> static constexpr auto rule(term<A>, term<A>) -> ctll::pop_input;
	
	// if the type on stack (range, set, neg_set, anything) is constructible from the terminal => pop_input
	template <typename Expected, auto V> static constexpr auto rule(Expected, term<V>) -> std::enable_if_t<std::is_constructible_v<Expected, term<V>>, ctll::pop_input>;
	
	// empty stack and empty input means we are accepting 
	static constexpr auto rule(empty_stack_symbol, epsilon) -> ctll::accept;
	
	// not matching anything else => reject
	static constexpr auto rule(...) -> ctll::reject;
	
	// start stack is just a list<Grammar::_start>;
	using start_stack = list<typename Grammar::_start>;
};

}

#endif

#ifndef CTLL__ACTIONS__HPP
#define CTLL__ACTIONS__HPP

namespace ctll {
	struct empty_subject { };
	
	struct empty_actions {
		// dummy operator so using Actions::operator() later will not give error
		template <typename Action, typename InputSymbol, typename Subject> static constexpr auto apply(Action, InputSymbol, Subject subject) {
			return subject;
		}
	};
	
	template <typename Actions> struct identity: public Actions {
		using Actions::apply;
		// allow empty_subject to exists
		template <typename Action, auto V> constexpr static auto apply(Action, term<V>, empty_subject) -> empty_subject { return {}; }
		template <typename Action> constexpr static auto apply(Action, epsilon, empty_subject) -> empty_subject { return {}; }	
	};
	
	template <typename Actions> struct ignore_unknown: public Actions {
		using Actions::apply;
		// allow flow thru unknown actions
		template <typename Action, auto V, typename Subject> constexpr static auto apply(Action, term<V>, Subject) -> Subject { return {}; }
		template <typename Action, typename Subject> constexpr static auto apply(Action, epsilon, Subject) -> Subject { return {}; }	
	};
}

#endif

#include <limits>

namespace ctll {

enum class decision {
	reject,
	accept,
	undecided
};

struct placeholder { };

template <size_t> using index_placeholder = placeholder;

#if !__cpp_nontype_template_parameter_class
template <typename Grammar, const auto & input, typename ActionSelector = empty_actions, bool IgnoreUnknownActions = false> struct parser {
#else
template <typename Grammar, ctll::fixed_string input, typename ActionSelector = empty_actions, bool IgnoreUnknownActions = false> struct parser { // in c++20
#endif
	
	#ifdef __GNUC__ // workaround to GCC bug
		#if __cpp_nontype_template_parameter_class
		static constexpr auto _input = input;  // c++20 mode
		#else
		static constexpr auto & _input = input; // c++17 mode
		#endif
	#else
		static constexpr auto _input = input; // everyone else
	#endif

	using Actions = ctll::conditional<IgnoreUnknownActions, ignore_unknown<ActionSelector>, identity<ActionSelector>>;
	using grammar = augment_grammar<Grammar>;
	
	template <size_t Pos, typename Stack, typename Subject, decision Decision> struct results {
		constexpr inline CTLL_FORCE_INLINE operator bool() const noexcept {
			return Decision == decision::accept;
		}
		
		#ifdef __GNUC__ // workaround to GCC bug
			#if __cpp_nontype_template_parameter_class
			static constexpr auto _input = input;  // c++20 mode
			#else
			static constexpr auto & _input = input; // c++17 mode
			#endif
		#else
			static constexpr auto _input = input; // everyone else
		#endif
	
		using output_type = Subject;
    
		constexpr auto operator+(placeholder) const noexcept {
			if constexpr (Decision == decision::undecided) {
				// parse for current char (RPos) with previous stack and subject :)
				return parser<Grammar, _input, ActionSelector, IgnoreUnknownActions>::template decide<Pos, Stack, Subject>({}, {});
			} else {
				// if there is decision already => just push it to the end of fold expression
				return *this;
			}
		}
	};
	
	template <size_t Pos> static constexpr auto get_current_term() noexcept {
		if constexpr (Pos < input.size()) {
			constexpr auto value = input[Pos];
			if constexpr (value <= std::numeric_limits<char>::max()) {
				return term<static_cast<char>(value)>{};
			} else {
				return term<input[Pos]>{};
			}
			
		} else {
			// return epsilon if we are past the input
			return epsilon{};
		}
	}
	template <size_t Pos> static constexpr auto get_previous_term() noexcept {
		if constexpr (Pos == 0) {
			// there is no previous character on input if we are on start
			return epsilon{};
		} else if constexpr ((Pos-1) < input.size()) {
			constexpr auto value = input[Pos-1];
			if constexpr (value <= std::numeric_limits<char>::max()) {
				return term<static_cast<char>(value)>{};
			} else {
				return term<value>{};
			}
		} else {
			return epsilon{};
		}
	}
	// if rule is accept => return true and subject
	template <size_t Pos, typename Terminal, typename Stack, typename Subject> 
	static constexpr auto move(ctll::accept, Terminal, Stack, Subject) noexcept {
		return typename parser<Grammar, _input, ActionSelector, IgnoreUnknownActions>::template results<Pos, Stack, Subject, decision::accept>();
	}
	// if rule is reject => return false and subject
	template <size_t Pos, typename Terminal, typename Stack, typename Subject>
	static constexpr auto move(ctll::reject, Terminal, Stack, Subject) noexcept {
		return typename parser<Grammar, _input, ActionSelector, IgnoreUnknownActions>::template results<Pos, Stack, Subject, decision::reject>();
	}
	// if rule is pop_input => move to next character
	template <size_t Pos, typename Terminal, typename Stack, typename Subject>
	static constexpr auto move(ctll::pop_input, Terminal, Stack, Subject) noexcept {
		return typename parser<Grammar, _input, ActionSelector, IgnoreUnknownActions>::template results<Pos+1, Stack, Subject, decision::undecided>();
	}
	// if rule is string => push it to the front of stack
	template <size_t Pos, typename... Content, typename Terminal, typename Stack, typename Subject>
	static constexpr auto move(push<Content...> string, Terminal, Stack stack, Subject subject) noexcept {
		return decide<Pos>(push_front(string, stack), subject);
	}
	// if rule is epsilon (empty string) => continue
	template <size_t Pos, typename Terminal, typename Stack, typename Subject>
	static constexpr auto move(epsilon, Terminal, Stack stack, Subject subject) noexcept {
		return decide<Pos>(stack, subject);
	}
	// if rule is string with current character at the beginning (term<V>) => move to next character 
	// and push string without the character (quick LL(1))
	template <size_t Pos, auto V, typename... Content, typename Stack, typename Subject>
	static constexpr auto move(push<term<V>, Content...>, term<V>, Stack stack, Subject) noexcept {
		constexpr auto _input = input;
		return typename parser<Grammar, _input, ActionSelector, IgnoreUnknownActions>::template results<Pos+1, decltype(push_front(list<Content...>(), stack)), Subject, decision::undecided>();
	}
	// if rule is string with any character at the beginning (compatible with current term<T>) => move to next character 
	// and push string without the character (quick LL(1))
	template <size_t Pos, auto V, typename... Content, auto T, typename Stack, typename Subject>
	static constexpr auto move(push<anything, Content...>, term<T>, Stack stack, Subject) noexcept {
		constexpr auto _input = input;
		return typename parser<Grammar, _input, ActionSelector, IgnoreUnknownActions>::template results<Pos+1, decltype(push_front(list<Content...>(), stack)), Subject, decision::undecided>();
	}
	// decide if we need to take action or move
	template <size_t Pos, typename Stack, typename Subject> static constexpr auto decide(Stack previous_stack, Subject previous_subject) noexcept {
		// each call means we pop something from stack
		auto top_symbol = decltype(ctll::front(previous_stack, empty_stack_symbol()))();
		// gcc pedantic warning
		[[maybe_unused]] auto stack = decltype(ctll::pop_front(previous_stack))();
		
		// in case top_symbol is action type (apply it on previous subject and get new one)
		if constexpr (std::is_base_of_v<ctll::action, decltype(top_symbol)>) {
			auto subject = Actions::apply(top_symbol, get_previous_term<Pos>(), previous_subject);
			
			// in case that semantic action is error => reject input
			if constexpr (std::is_same_v<ctll::reject, decltype(subject)>) {
				return typename parser<Grammar, _input, ActionSelector, IgnoreUnknownActions>::template results<Pos, Stack, Subject, decision::reject>();
			} else {
				return decide<Pos>(stack, subject);
			}
		} else {
			// all other cases are ordinary for LL(1) parser
			auto current_term = get_current_term<Pos>();
			auto rule = decltype(grammar::rule(top_symbol,current_term))();
			return move<Pos>(rule, current_term, stack, previous_subject);
		}
	}
	
	// trampolines with folded expression
	template <typename Subject, size_t... Pos> static constexpr auto trampoline_decide(Subject, std::index_sequence<Pos...>) noexcept {
		// parse everything for first char and than for next and next ...
		// Pos+1 is needed as we want to finish calculation with epsilons on stack
		auto v = (decide<0, typename grammar::start_stack, Subject>({}, {}) + ... + index_placeholder<Pos+1>());
		return v;
	}
	
	template <typename Subject = empty_subject> static constexpr auto trampoline_decide(Subject subject = {}) noexcept {
		// there will be no recursion, just sequence long as the input
		return trampoline_decide(subject, std::make_index_sequence<input.size()>());
	}
	
	template <typename Subject = empty_subject> using output = decltype(trampoline_decide<Subject>());
	template <typename Subject = empty_subject> static inline constexpr bool correct_with = trampoline_decide<Subject>();

};

} // end of ctll namespace

#endif

#endif

#ifndef CTRE__PCRE_ACTIONS__HPP
#define CTRE__PCRE_ACTIONS__HPP

#ifndef CTRE__PCRE__HPP
#define CTRE__PCRE__HPP

// THIS FILE WAS GENERATED BY DESATOMAT TOOL, DO NOT MODIFY THIS FILE

namespace ctre {

struct pcre {

// NONTERMINALS:
	struct a {};
	struct b {};
	struct backslash {};
	struct backslash_range {};
	struct block {};
	struct block_name2 {};
	struct block_name {};
	struct c {};
	struct class_named_name {};
	struct content2 {};
	struct content_in_capture {};
	struct d {};
	struct e {};
	struct f {};
	struct g {};
	struct h {};
	struct hexdec_repeat {};
	struct i {};
	struct j {};
	struct k {};
	struct l {};
	struct m {};
	struct mod {};
	struct mod_opt {};
	struct n {};
	struct number2 {};
	struct number {};
	struct property_name2 {};
	struct property_name {};
	struct property_value2 {};
	struct property_value {};
	struct range {};
	struct repeat {};
	struct s {}; using _start = s;
	struct set2 {};
	struct set {};
	struct string2 {};

// 'action' types:
	struct class_digit: ctll::action {};
	struct class_named_alnum: ctll::action {};
	struct class_named_alpha: ctll::action {};
	struct class_named_ascii: ctll::action {};
	struct class_named_blank: ctll::action {};
	struct class_named_cntrl: ctll::action {};
	struct class_named_digit: ctll::action {};
	struct class_named_graph: ctll::action {};
	struct class_named_lower: ctll::action {};
	struct class_named_print: ctll::action {};
	struct class_named_punct: ctll::action {};
	struct class_named_space: ctll::action {};
	struct class_named_upper: ctll::action {};
	struct class_named_word: ctll::action {};
	struct class_named_xdigit: ctll::action {};
	struct class_nondigit: ctll::action {};
	struct class_nonnewline: ctll::action {};
	struct class_nonspace: ctll::action {};
	struct class_nonword: ctll::action {};
	struct class_space: ctll::action {};
	struct class_word: ctll::action {};
	struct create_hexdec: ctll::action {};
	struct create_number: ctll::action {};
	struct finish_hexdec: ctll::action {};
	struct look_finish: ctll::action {};
	struct make_alternate: ctll::action {};
	struct make_back_reference: ctll::action {};
	struct make_capture: ctll::action {};
	struct make_capture_with_name: ctll::action {};
	struct make_lazy: ctll::action {};
	struct make_optional: ctll::action {};
	struct make_possessive: ctll::action {};
	struct make_property: ctll::action {};
	struct make_property_negative: ctll::action {};
	struct make_range: ctll::action {};
	struct make_relative_back_reference: ctll::action {};
	struct make_sequence: ctll::action {};
	struct negate_class_named: ctll::action {};
	struct prepare_capture: ctll::action {};
	struct push_assert_begin: ctll::action {};
	struct push_assert_end: ctll::action {};
	struct push_character: ctll::action {};
	struct push_character_alarm: ctll::action {};
	struct push_character_anything: ctll::action {};
	struct push_character_escape: ctll::action {};
	struct push_character_formfeed: ctll::action {};
	struct push_character_newline: ctll::action {};
	struct push_character_null: ctll::action {};
	struct push_character_return_carriage: ctll::action {};
	struct push_character_tab: ctll::action {};
	struct push_empty: ctll::action {};
	struct push_hexdec: ctll::action {};
	struct push_name: ctll::action {};
	struct push_number: ctll::action {};
	struct push_property_name: ctll::action {};
	struct push_property_value: ctll::action {};
	struct repeat_ab: ctll::action {};
	struct repeat_at_least: ctll::action {};
	struct repeat_exactly: ctll::action {};
	struct repeat_plus: ctll::action {};
	struct repeat_star: ctll::action {};
	struct reset_capture: ctll::action {};
	struct set_combine: ctll::action {};
	struct set_make: ctll::action {};
	struct set_make_negative: ctll::action {};
	struct set_start: ctll::action {};
	struct start_lookahead_negative: ctll::action {};
	struct start_lookahead_positive: ctll::action {};

// (q)LL1 function:
	using _others = ctll::neg_set<'!','$','\x28','\x29','*','+',',','-','.',':','<','=','>','?','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','^','_','a','b','c','d','e','f','g','h','0','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','\x7B','|','\x7D','1','2','3','4','5','6','7','8','9'>;
	static constexpr auto rule(s, ctll::term<'\\'>) -> ctll::push<ctll::anything, backslash, repeat, string2, content2>;
	static constexpr auto rule(s, ctll::term<'['>) -> ctll::push<ctll::anything, c, repeat, string2, content2>;
	static constexpr auto rule(s, ctll::term<'\x28'>) -> ctll::push<ctll::anything, prepare_capture, block, repeat, string2, content2>;
	static constexpr auto rule(s, ctll::term<'^'>) -> ctll::push<ctll::anything, push_assert_begin, repeat, string2, content2>;
	static constexpr auto rule(s, ctll::term<'$'>) -> ctll::push<ctll::anything, push_assert_end, repeat, string2, content2>;
	static constexpr auto rule(s, ctll::set<'!',',','-',':','<','=','>','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T',']','_','0','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_character, repeat, string2, content2>;
	static constexpr auto rule(s, _others) -> ctll::push<ctll::anything, push_character, repeat, string2, content2>;
	static constexpr auto rule(s, ctll::term<'.'>) -> ctll::push<ctll::anything, push_character_anything, repeat, string2, content2>;
	static constexpr auto rule(s, ctll::epsilon) -> ctll::push<push_empty>;
	static constexpr auto rule(s, ctll::set<'\x29','*','+','?','\x7B','|','\x7D'>) -> ctll::reject;

	static constexpr auto rule(a, ctll::term<'\\'>) -> ctll::push<ctll::anything, backslash, repeat, string2, content2, make_alternate>;
	static constexpr auto rule(a, ctll::term<'['>) -> ctll::push<ctll::anything, c, repeat, string2, content2, make_alternate>;
	static constexpr auto rule(a, ctll::term<'\x28'>) -> ctll::push<ctll::anything, prepare_capture, block, repeat, string2, content2, make_alternate>;
	static constexpr auto rule(a, ctll::term<'^'>) -> ctll::push<ctll::anything, push_assert_begin, repeat, string2, content2, make_alternate>;
	static constexpr auto rule(a, ctll::term<'$'>) -> ctll::push<ctll::anything, push_assert_end, repeat, string2, content2, make_alternate>;
	static constexpr auto rule(a, ctll::set<'!',',','-',':','<','=','>','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T',']','_','0','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_character, repeat, string2, content2, make_alternate>;
	static constexpr auto rule(a, _others) -> ctll::push<ctll::anything, push_character, repeat, string2, content2, make_alternate>;
	static constexpr auto rule(a, ctll::term<'.'>) -> ctll::push<ctll::anything, push_character_anything, repeat, string2, content2, make_alternate>;
	static constexpr auto rule(a, ctll::term<'\x29'>) -> ctll::push<push_empty, make_alternate>;
	static constexpr auto rule(a, ctll::epsilon) -> ctll::push<push_empty, make_alternate>;
	static constexpr auto rule(a, ctll::set<'*','+','?','\x7B','|','\x7D'>) -> ctll::reject;

	static constexpr auto rule(b, ctll::term<','>) -> ctll::push<ctll::anything, m>;
	static constexpr auto rule(b, ctll::term<'\x7D'>) -> ctll::push<repeat_exactly, ctll::anything>;

	static constexpr auto rule(backslash, ctll::term<'d'>) -> ctll::push<ctll::anything, class_digit>;
	static constexpr auto rule(backslash, ctll::term<'D'>) -> ctll::push<ctll::anything, class_nondigit>;
	static constexpr auto rule(backslash, ctll::term<'N'>) -> ctll::push<ctll::anything, class_nonnewline>;
	static constexpr auto rule(backslash, ctll::term<'S'>) -> ctll::push<ctll::anything, class_nonspace>;
	static constexpr auto rule(backslash, ctll::term<'W'>) -> ctll::push<ctll::anything, class_nonword>;
	static constexpr auto rule(backslash, ctll::term<'s'>) -> ctll::push<ctll::anything, class_space>;
	static constexpr auto rule(backslash, ctll::term<'w'>) -> ctll::push<ctll::anything, class_word>;
	static constexpr auto rule(backslash, ctll::term<'g'>) -> ctll::push<ctll::anything, ctll::term<'\x7B'>, l>;
	static constexpr auto rule(backslash, ctll::term<'p'>) -> ctll::push<ctll::anything, ctll::term<'\x7B'>, property_name, ctll::term<'\x7D'>, make_property>;
	static constexpr auto rule(backslash, ctll::term<'P'>) -> ctll::push<ctll::anything, ctll::term<'\x7B'>, property_name, ctll::term<'\x7D'>, make_property_negative>;
	static constexpr auto rule(backslash, ctll::term<'u'>) -> ctll::push<ctll::anything, j>;
	static constexpr auto rule(backslash, ctll::term<'x'>) -> ctll::push<ctll::anything, k>;
	static constexpr auto rule(backslash, ctll::set<'$','\x28','\x29','*','+','-','.','?','A','B','C','E','F','G','H','I','J','K','L','M','O','Q','U','V','X','Y','Z','[','\\',']','^','b','c','h','i','j','k','l','m','o','q','v','y','z','\x7B','|','\x7D','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_character>;
	static constexpr auto rule(backslash, ctll::term<'a'>) -> ctll::push<ctll::anything, push_character_alarm>;
	static constexpr auto rule(backslash, ctll::term<'e'>) -> ctll::push<ctll::anything, push_character_escape>;
	static constexpr auto rule(backslash, ctll::term<'f'>) -> ctll::push<ctll::anything, push_character_formfeed>;
	static constexpr auto rule(backslash, ctll::term<'n'>) -> ctll::push<ctll::anything, push_character_newline>;
	static constexpr auto rule(backslash, ctll::term<'0'>) -> ctll::push<ctll::anything, push_character_null>;
	static constexpr auto rule(backslash, ctll::term<'r'>) -> ctll::push<ctll::anything, push_character_return_carriage>;
	static constexpr auto rule(backslash, ctll::term<'t'>) -> ctll::push<ctll::anything, push_character_tab>;

	static constexpr auto rule(backslash_range, ctll::term<'u'>) -> ctll::push<ctll::anything, j>;
	static constexpr auto rule(backslash_range, ctll::term<'x'>) -> ctll::push<ctll::anything, k>;
	static constexpr auto rule(backslash_range, ctll::term<'a'>) -> ctll::push<ctll::anything, push_character_alarm>;
	static constexpr auto rule(backslash_range, ctll::term<'e'>) -> ctll::push<ctll::anything, push_character_escape>;
	static constexpr auto rule(backslash_range, ctll::term<'f'>) -> ctll::push<ctll::anything, push_character_formfeed>;
	static constexpr auto rule(backslash_range, ctll::term<'n'>) -> ctll::push<ctll::anything, push_character_newline>;
	static constexpr auto rule(backslash_range, ctll::term<'0'>) -> ctll::push<ctll::anything, push_character_null>;
	static constexpr auto rule(backslash_range, ctll::term<'r'>) -> ctll::push<ctll::anything, push_character_return_carriage>;
	static constexpr auto rule(backslash_range, ctll::term<'t'>) -> ctll::push<ctll::anything, push_character_tab>;

	static constexpr auto rule(block, ctll::term<'\\'>) -> ctll::push<ctll::anything, backslash, repeat, string2, content2, make_capture, ctll::term<'\x29'>>;
	static constexpr auto rule(block, ctll::term<'['>) -> ctll::push<ctll::anything, c, repeat, string2, content2, make_capture, ctll::term<'\x29'>>;
	static constexpr auto rule(block, ctll::term<'?'>) -> ctll::push<ctll::anything, d>;
	static constexpr auto rule(block, ctll::term<'\x28'>) -> ctll::push<ctll::anything, prepare_capture, block, repeat, string2, content2, make_capture, ctll::term<'\x29'>>;
	static constexpr auto rule(block, ctll::term<'^'>) -> ctll::push<ctll::anything, push_assert_begin, repeat, string2, content2, make_capture, ctll::term<'\x29'>>;
	static constexpr auto rule(block, ctll::term<'$'>) -> ctll::push<ctll::anything, push_assert_end, repeat, string2, content2, make_capture, ctll::term<'\x29'>>;
	static constexpr auto rule(block, ctll::set<'!',',','-',':','<','=','>','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T',']','_','0','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_character, repeat, string2, content2, make_capture, ctll::term<'\x29'>>;
	static constexpr auto rule(block, _others) -> ctll::push<ctll::anything, push_character, repeat, string2, content2, make_capture, ctll::term<'\x29'>>;
	static constexpr auto rule(block, ctll::term<'.'>) -> ctll::push<ctll::anything, push_character_anything, repeat, string2, content2, make_capture, ctll::term<'\x29'>>;
	static constexpr auto rule(block, ctll::term<'\x29'>) -> ctll::push<push_empty, make_capture, ctll::anything>;
	static constexpr auto rule(block, ctll::set<'*','+','\x7B','|','\x7D'>) -> ctll::reject;

	static constexpr auto rule(block_name2, ctll::set<'>','\x7D'>) -> ctll::epsilon;
	static constexpr auto rule(block_name2, ctll::set<'0','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_name, block_name2>;

	static constexpr auto rule(block_name, ctll::set<'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'>) -> ctll::push<ctll::anything, push_name, block_name2>;

	static constexpr auto rule(c, ctll::term<'['>) -> ctll::push<ctll::anything, ctll::term<':'>, h, range, set_start, set2, set_make, ctll::term<']'>>;
	static constexpr auto rule(c, ctll::term<'\\'>) -> ctll::push<ctll::anything, e, set_start, set2, set_make, ctll::term<']'>>;
	static constexpr auto rule(c, ctll::set<'!','$','\x28','\x29','*','+',',','.',':','<','=','>','?','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','0','s','t','u','v','w','x','y','z','\x7B','\x7D','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_character, range, set_start, set2, set_make, ctll::term<']'>>;
	static constexpr auto rule(c, _others) -> ctll::push<ctll::anything, push_character, range, set_start, set2, set_make, ctll::term<']'>>;
	static constexpr auto rule(c, ctll::term<'-'>) -> ctll::push<ctll::anything, push_character, set_start, set2, set_make, ctll::term<']'>>;
	static constexpr auto rule(c, ctll::term<'^'>) -> ctll::push<ctll::anything, set, set_make_negative, ctll::term<']'>>;
	static constexpr auto rule(c, ctll::set<']','|'>) -> ctll::reject;

	static constexpr auto rule(class_named_name, ctll::term<'x'>) -> ctll::push<ctll::anything, ctll::term<'d'>, ctll::term<'i'>, ctll::term<'g'>, ctll::term<'i'>, ctll::term<'t'>, class_named_xdigit>;
	static constexpr auto rule(class_named_name, ctll::term<'d'>) -> ctll::push<ctll::anything, ctll::term<'i'>, ctll::term<'g'>, ctll::term<'i'>, ctll::term<'t'>, class_named_digit>;
	static constexpr auto rule(class_named_name, ctll::term<'b'>) -> ctll::push<ctll::anything, ctll::term<'l'>, ctll::term<'a'>, ctll::term<'n'>, ctll::term<'k'>, class_named_blank>;
	static constexpr auto rule(class_named_name, ctll::term<'c'>) -> ctll::push<ctll::anything, ctll::term<'n'>, ctll::term<'t'>, ctll::term<'r'>, ctll::term<'l'>, class_named_cntrl>;
	static constexpr auto rule(class_named_name, ctll::term<'w'>) -> ctll::push<ctll::anything, ctll::term<'o'>, ctll::term<'r'>, ctll::term<'d'>, class_named_word>;
	static constexpr auto rule(class_named_name, ctll::term<'l'>) -> ctll::push<ctll::anything, ctll::term<'o'>, ctll::term<'w'>, ctll::term<'e'>, ctll::term<'r'>, class_named_lower>;
	static constexpr auto rule(class_named_name, ctll::term<'s'>) -> ctll::push<ctll::anything, ctll::term<'p'>, ctll::term<'a'>, ctll::term<'c'>, ctll::term<'e'>, class_named_space>;
	static constexpr auto rule(class_named_name, ctll::term<'u'>) -> ctll::push<ctll::anything, ctll::term<'p'>, ctll::term<'p'>, ctll::term<'e'>, ctll::term<'r'>, class_named_upper>;
	static constexpr auto rule(class_named_name, ctll::term<'g'>) -> ctll::push<ctll::anything, ctll::term<'r'>, ctll::term<'a'>, ctll::term<'p'>, ctll::term<'h'>, class_named_graph>;
	static constexpr auto rule(class_named_name, ctll::term<'a'>) -> ctll::push<ctll::anything, f>;
	static constexpr auto rule(class_named_name, ctll::term<'p'>) -> ctll::push<ctll::anything, g>;

	static constexpr auto rule(content2, ctll::term<'\x29'>) -> ctll::epsilon;
	static constexpr auto rule(content2, ctll::epsilon) -> ctll::epsilon;
	static constexpr auto rule(content2, ctll::term<'|'>) -> ctll::push<ctll::anything, a>;

	static constexpr auto rule(content_in_capture, ctll::term<'\\'>) -> ctll::push<ctll::anything, backslash, repeat, string2, content2>;
	static constexpr auto rule(content_in_capture, ctll::term<'['>) -> ctll::push<ctll::anything, c, repeat, string2, content2>;
	static constexpr auto rule(content_in_capture, ctll::term<'\x28'>) -> ctll::push<ctll::anything, prepare_capture, block, repeat, string2, content2>;
	static constexpr auto rule(content_in_capture, ctll::term<'^'>) -> ctll::push<ctll::anything, push_assert_begin, repeat, string2, content2>;
	static constexpr auto rule(content_in_capture, ctll::term<'$'>) -> ctll::push<ctll::anything, push_assert_end, repeat, string2, content2>;
	static constexpr auto rule(content_in_capture, ctll::set<'!',',','-',':','<','=','>','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T',']','_','0','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_character, repeat, string2, content2>;
	static constexpr auto rule(content_in_capture, _others) -> ctll::push<ctll::anything, push_character, repeat, string2, content2>;
	static constexpr auto rule(content_in_capture, ctll::term<'.'>) -> ctll::push<ctll::anything, push_character_anything, repeat, string2, content2>;
	static constexpr auto rule(content_in_capture, ctll::term<'\x29'>) -> ctll::push<push_empty>;
	static constexpr auto rule(content_in_capture, ctll::set<'*','+','?','\x7B','|','\x7D'>) -> ctll::reject;

	static constexpr auto rule(d, ctll::term<'<'>) -> ctll::push<ctll::anything, block_name, ctll::term<'>'>, content_in_capture, make_capture_with_name, ctll::term<'\x29'>>;
	static constexpr auto rule(d, ctll::term<':'>) -> ctll::push<reset_capture, ctll::anything, content_in_capture, ctll::term<'\x29'>>;
	static constexpr auto rule(d, ctll::term<'!'>) -> ctll::push<reset_capture, ctll::anything, start_lookahead_negative, content_in_capture, look_finish, ctll::term<'\x29'>>;
	static constexpr auto rule(d, ctll::term<'='>) -> ctll::push<reset_capture, ctll::anything, start_lookahead_positive, content_in_capture, look_finish, ctll::term<'\x29'>>;

	static constexpr auto rule(e, ctll::term<'d'>) -> ctll::push<ctll::anything, class_digit>;
	static constexpr auto rule(e, ctll::term<'D'>) -> ctll::push<ctll::anything, class_nondigit>;
	static constexpr auto rule(e, ctll::term<'N'>) -> ctll::push<ctll::anything, class_nonnewline>;
	static constexpr auto rule(e, ctll::term<'S'>) -> ctll::push<ctll::anything, class_nonspace>;
	static constexpr auto rule(e, ctll::term<'W'>) -> ctll::push<ctll::anything, class_nonword>;
	static constexpr auto rule(e, ctll::term<'s'>) -> ctll::push<ctll::anything, class_space>;
	static constexpr auto rule(e, ctll::term<'w'>) -> ctll::push<ctll::anything, class_word>;
	static constexpr auto rule(e, ctll::term<'p'>) -> ctll::push<ctll::anything, ctll::term<'\x7B'>, property_name, ctll::term<'\x7D'>, make_property>;
	static constexpr auto rule(e, ctll::term<'P'>) -> ctll::push<ctll::anything, ctll::term<'\x7B'>, property_name, ctll::term<'\x7D'>, make_property_negative>;
	static constexpr auto rule(e, ctll::term<'u'>) -> ctll::push<ctll::anything, j, range>;
	static constexpr auto rule(e, ctll::term<'x'>) -> ctll::push<ctll::anything, k, range>;
	static constexpr auto rule(e, ctll::set<'$','\x28','\x29','*','+','-','.','?','A','B','C','E','F','G','H','I','J','K','L','M','O','Q','U','V','X','Y','Z','[','\\',']','^','b','c','h','i','j','k','l','m','o','q','v','y','z','\x7B','|','\x7D','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_character>;
	static constexpr auto rule(e, ctll::term<'a'>) -> ctll::push<ctll::anything, push_character_alarm, range>;
	static constexpr auto rule(e, ctll::term<'e'>) -> ctll::push<ctll::anything, push_character_escape, range>;
	static constexpr auto rule(e, ctll::term<'f'>) -> ctll::push<ctll::anything, push_character_formfeed, range>;
	static constexpr auto rule(e, ctll::term<'n'>) -> ctll::push<ctll::anything, push_character_newline, range>;
	static constexpr auto rule(e, ctll::term<'0'>) -> ctll::push<ctll::anything, push_character_null, range>;
	static constexpr auto rule(e, ctll::term<'r'>) -> ctll::push<ctll::anything, push_character_return_carriage, range>;
	static constexpr auto rule(e, ctll::term<'t'>) -> ctll::push<ctll::anything, push_character_tab, range>;

	static constexpr auto rule(f, ctll::term<'s'>) -> ctll::push<ctll::anything, ctll::term<'c'>, ctll::term<'i'>, ctll::term<'i'>, class_named_ascii>;
	static constexpr auto rule(f, ctll::term<'l'>) -> ctll::push<ctll::anything, n>;

	static constexpr auto rule(g, ctll::term<'r'>) -> ctll::push<ctll::anything, ctll::term<'i'>, ctll::term<'n'>, ctll::term<'t'>, class_named_print>;
	static constexpr auto rule(g, ctll::term<'u'>) -> ctll::push<ctll::anything, ctll::term<'n'>, ctll::term<'c'>, ctll::term<'t'>, class_named_punct>;

	static constexpr auto rule(h, ctll::term<'^'>) -> ctll::push<ctll::anything, class_named_name, negate_class_named, ctll::term<':'>, ctll::term<']'>>;
	static constexpr auto rule(h, ctll::term<'x'>) -> ctll::push<ctll::anything, ctll::term<'d'>, ctll::term<'i'>, ctll::term<'g'>, ctll::term<'i'>, ctll::term<'t'>, class_named_xdigit, ctll::term<':'>, ctll::term<']'>>;
	static constexpr auto rule(h, ctll::term<'d'>) -> ctll::push<ctll::anything, ctll::term<'i'>, ctll::term<'g'>, ctll::term<'i'>, ctll::term<'t'>, class_named_digit, ctll::term<':'>, ctll::term<']'>>;
	static constexpr auto rule(h, ctll::term<'b'>) -> ctll::push<ctll::anything, ctll::term<'l'>, ctll::term<'a'>, ctll::term<'n'>, ctll::term<'k'>, class_named_blank, ctll::term<':'>, ctll::term<']'>>;
	static constexpr auto rule(h, ctll::term<'c'>) -> ctll::push<ctll::anything, ctll::term<'n'>, ctll::term<'t'>, ctll::term<'r'>, ctll::term<'l'>, class_named_cntrl, ctll::term<':'>, ctll::term<']'>>;
	static constexpr auto rule(h, ctll::term<'w'>) -> ctll::push<ctll::anything, ctll::term<'o'>, ctll::term<'r'>, ctll::term<'d'>, class_named_word, ctll::term<':'>, ctll::term<']'>>;
	static constexpr auto rule(h, ctll::term<'l'>) -> ctll::push<ctll::anything, ctll::term<'o'>, ctll::term<'w'>, ctll::term<'e'>, ctll::term<'r'>, class_named_lower, ctll::term<':'>, ctll::term<']'>>;
	static constexpr auto rule(h, ctll::term<'s'>) -> ctll::push<ctll::anything, ctll::term<'p'>, ctll::term<'a'>, ctll::term<'c'>, ctll::term<'e'>, class_named_space, ctll::term<':'>, ctll::term<']'>>;
	static constexpr auto rule(h, ctll::term<'u'>) -> ctll::push<ctll::anything, ctll::term<'p'>, ctll::term<'p'>, ctll::term<'e'>, ctll::term<'r'>, class_named_upper, ctll::term<':'>, ctll::term<']'>>;
	static constexpr auto rule(h, ctll::term<'g'>) -> ctll::push<ctll::anything, ctll::term<'r'>, ctll::term<'a'>, ctll::term<'p'>, ctll::term<'h'>, class_named_graph, ctll::term<':'>, ctll::term<']'>>;
	static constexpr auto rule(h, ctll::term<'a'>) -> ctll::push<ctll::anything, f, ctll::term<':'>, ctll::term<']'>>;
	static constexpr auto rule(h, ctll::term<'p'>) -> ctll::push<ctll::anything, g, ctll::term<':'>, ctll::term<']'>>;

	static constexpr auto rule(hexdec_repeat, ctll::term<'\x7D'>) -> ctll::epsilon;
	static constexpr auto rule(hexdec_repeat, ctll::set<'0','A','B','C','D','E','F','a','b','c','d','e','f','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_hexdec, hexdec_repeat>;

	static constexpr auto rule(i, ctll::term<'\\'>) -> ctll::push<ctll::anything, backslash_range, make_range>;
	static constexpr auto rule(i, ctll::set<'!','$','\x28','\x29','*','+',',','.',':','<','=','>','?','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','0','s','t','u','v','w','x','y','z','\x7B','\x7D','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_character, make_range>;
	static constexpr auto rule(i, _others) -> ctll::push<ctll::anything, push_character, make_range>;
	static constexpr auto rule(i, ctll::set<'-','[',']','^','|'>) -> ctll::reject;

	static constexpr auto rule(j, ctll::term<'\x7B'>) -> ctll::push<create_hexdec, ctll::anything, ctll::set<'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f'>, push_hexdec, hexdec_repeat, ctll::term<'\x7D'>, finish_hexdec>;
	static constexpr auto rule(j, ctll::set<'0','A','B','C','D','E','F','a','b','c','d','e','f','1','2','3','4','5','6','7','8','9'>) -> ctll::push<create_hexdec, ctll::anything, push_hexdec, ctll::set<'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f'>, push_hexdec, ctll::set<'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f'>, push_hexdec, ctll::set<'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f'>, push_hexdec, finish_hexdec>;

	static constexpr auto rule(k, ctll::term<'\x7B'>) -> ctll::push<create_hexdec, ctll::anything, ctll::set<'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f'>, push_hexdec, hexdec_repeat, ctll::term<'\x7D'>, finish_hexdec>;
	static constexpr auto rule(k, ctll::set<'0','A','B','C','D','E','F','a','b','c','d','e','f','1','2','3','4','5','6','7','8','9'>) -> ctll::push<create_hexdec, ctll::anything, push_hexdec, ctll::set<'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f'>, push_hexdec, finish_hexdec>;

	static constexpr auto rule(l, ctll::set<'0','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, create_number, number2, ctll::term<'\x7D'>, make_back_reference>;
	static constexpr auto rule(l, ctll::term<'-'>) -> ctll::push<ctll::anything, number, ctll::term<'\x7D'>, make_relative_back_reference>;
	static constexpr auto rule(l, ctll::set<'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'>) -> ctll::push<ctll::anything, push_name, block_name2, ctll::term<'\x7D'>, make_back_reference>;

	static constexpr auto rule(m, ctll::set<'0','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, create_number, number2, repeat_ab, ctll::term<'\x7D'>, mod>;
	static constexpr auto rule(m, ctll::term<'\x7D'>) -> ctll::push<repeat_at_least, ctll::anything, mod>;

	static constexpr auto rule(mod, ctll::set<'!','$','\x28','\x29',',','-','.',':','<','=','>','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','^','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','|','0','1','2','3','4','5','6','7','8','9'>) -> ctll::epsilon;
	static constexpr auto rule(mod, ctll::epsilon) -> ctll::epsilon;
	static constexpr auto rule(mod, _others) -> ctll::epsilon;
	static constexpr auto rule(mod, ctll::term<'?'>) -> ctll::push<ctll::anything, make_lazy>;
	static constexpr auto rule(mod, ctll::term<'+'>) -> ctll::push<ctll::anything, make_possessive>;
	static constexpr auto rule(mod, ctll::set<'*','\x7B','\x7D'>) -> ctll::reject;

	static constexpr auto rule(mod_opt, ctll::set<'!','$','\x28','\x29',',','-','.',':','<','=','>','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','^','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','|','0','1','2','3','4','5','6','7','8','9'>) -> ctll::epsilon;
	static constexpr auto rule(mod_opt, ctll::epsilon) -> ctll::epsilon;
	static constexpr auto rule(mod_opt, _others) -> ctll::epsilon;
	static constexpr auto rule(mod_opt, ctll::term<'?'>) -> ctll::push<ctll::anything, make_lazy>;
	static constexpr auto rule(mod_opt, ctll::set<'*','+','\x7B','\x7D'>) -> ctll::reject;

	static constexpr auto rule(n, ctll::term<'p'>) -> ctll::push<ctll::anything, ctll::term<'h'>, ctll::term<'a'>, class_named_alpha>;
	static constexpr auto rule(n, ctll::term<'n'>) -> ctll::push<ctll::anything, ctll::term<'u'>, ctll::term<'m'>, class_named_alnum>;

	static constexpr auto rule(number2, ctll::set<',','\x7D'>) -> ctll::epsilon;
	static constexpr auto rule(number2, ctll::set<'0','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_number, number2>;

	static constexpr auto rule(number, ctll::set<'0','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, create_number, number2>;

	static constexpr auto rule(property_name2, ctll::term<'\x7D'>) -> ctll::epsilon;
	static constexpr auto rule(property_name2, ctll::term<'='>) -> ctll::push<ctll::anything, property_value>;
	static constexpr auto rule(property_name2, ctll::set<'0','.','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_property_name, property_name2>;

	static constexpr auto rule(property_name, ctll::set<'0','.','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_property_name, property_name2>;

	static constexpr auto rule(property_value2, ctll::term<'\x7D'>) -> ctll::epsilon;
	static constexpr auto rule(property_value2, ctll::set<'0','.','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_property_value, property_value2>;

	static constexpr auto rule(property_value, ctll::set<'0','.','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_property_value, property_value2>;

	static constexpr auto rule(range, ctll::set<'!','$','\x28','\x29','*','+',',','.',':','<','=','>','?','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','\x7B','\x7D','0','1','2','3','4','5','6','7','8','9'>) -> ctll::epsilon;
	static constexpr auto rule(range, ctll::epsilon) -> ctll::epsilon;
	static constexpr auto rule(range, _others) -> ctll::epsilon;
	static constexpr auto rule(range, ctll::term<'-'>) -> ctll::push<ctll::anything, i>;
	static constexpr auto rule(range, ctll::set<'^','|'>) -> ctll::reject;

	static constexpr auto rule(repeat, ctll::set<'!','$','\x28','\x29',',','-','.',':','<','=','>','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','^','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','|','0','1','2','3','4','5','6','7','8','9'>) -> ctll::epsilon;
	static constexpr auto rule(repeat, ctll::epsilon) -> ctll::epsilon;
	static constexpr auto rule(repeat, _others) -> ctll::epsilon;
	static constexpr auto rule(repeat, ctll::term<'?'>) -> ctll::push<ctll::anything, make_optional, mod_opt>;
	static constexpr auto rule(repeat, ctll::term<'\x7B'>) -> ctll::push<ctll::anything, number, b>;
	static constexpr auto rule(repeat, ctll::term<'+'>) -> ctll::push<ctll::anything, repeat_plus, mod>;
	static constexpr auto rule(repeat, ctll::term<'*'>) -> ctll::push<ctll::anything, repeat_star, mod>;
	static constexpr auto rule(repeat, ctll::term<'\x7D'>) -> ctll::reject;

	static constexpr auto rule(set2, ctll::term<']'>) -> ctll::epsilon;
	static constexpr auto rule(set2, ctll::term<'['>) -> ctll::push<ctll::anything, ctll::term<':'>, h, range, set_combine, set2>;
	static constexpr auto rule(set2, ctll::term<'\\'>) -> ctll::push<ctll::anything, e, set_combine, set2>;
	static constexpr auto rule(set2, ctll::set<'!','$','\x28','\x29','*','+',',','.',':','<','=','>','?','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','0','s','t','u','v','w','x','y','z','\x7B','\x7D','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_character, range, set_combine, set2>;
	static constexpr auto rule(set2, _others) -> ctll::push<ctll::anything, push_character, range, set_combine, set2>;
	static constexpr auto rule(set2, ctll::set<'-','^','|'>) -> ctll::reject;

	static constexpr auto rule(set, ctll::term<'['>) -> ctll::push<ctll::anything, ctll::term<':'>, h, range, set_start, set2>;
	static constexpr auto rule(set, ctll::term<'\\'>) -> ctll::push<ctll::anything, e, set_start, set2>;
	static constexpr auto rule(set, ctll::set<'!','$','\x28','\x29','*','+',',','.',':','<','=','>','?','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','0','s','t','u','v','w','x','y','z','\x7B','\x7D','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_character, range, set_start, set2>;
	static constexpr auto rule(set, _others) -> ctll::push<ctll::anything, push_character, range, set_start, set2>;
	static constexpr auto rule(set, ctll::term<'-'>) -> ctll::push<ctll::anything, push_character, set_start, set2>;
	static constexpr auto rule(set, ctll::set<']','^','|'>) -> ctll::reject;

	static constexpr auto rule(string2, ctll::set<'\x29','|'>) -> ctll::epsilon;
	static constexpr auto rule(string2, ctll::epsilon) -> ctll::epsilon;
	static constexpr auto rule(string2, ctll::term<'\\'>) -> ctll::push<ctll::anything, backslash, repeat, string2, make_sequence>;
	static constexpr auto rule(string2, ctll::term<'['>) -> ctll::push<ctll::anything, c, repeat, string2, make_sequence>;
	static constexpr auto rule(string2, ctll::term<'\x28'>) -> ctll::push<ctll::anything, prepare_capture, block, repeat, string2, make_sequence>;
	static constexpr auto rule(string2, ctll::term<'^'>) -> ctll::push<ctll::anything, push_assert_begin, repeat, string2, make_sequence>;
	static constexpr auto rule(string2, ctll::term<'$'>) -> ctll::push<ctll::anything, push_assert_end, repeat, string2, make_sequence>;
	static constexpr auto rule(string2, ctll::set<'!',',','-',':','<','=','>','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T',']','_','0','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9'>) -> ctll::push<ctll::anything, push_character, repeat, string2, make_sequence>;
	static constexpr auto rule(string2, _others) -> ctll::push<ctll::anything, push_character, repeat, string2, make_sequence>;
	static constexpr auto rule(string2, ctll::term<'.'>) -> ctll::push<ctll::anything, push_character_anything, repeat, string2, make_sequence>;
	static constexpr auto rule(string2, ctll::set<'*','+','?','\x7B','\x7D'>) -> ctll::reject;

};

}

#endif //CTRE__PCRE__HPP

#ifndef CTRE__ATOMS__HPP
#define CTRE__ATOMS__HPP

#include <cstdint>

namespace ctre {
	
// special helpers for matching
struct accept { };
struct reject { };
struct start_mark { };
struct end_mark { };
struct end_cycle_mark { };
struct end_lookahead_mark { };
template <size_t Id> struct numeric_mark { };

// actual AST of regexp
template <auto... Str> struct string { };
template <typename... Opts> struct select { };
template <typename... Content> struct optional { };
template <typename... Content> struct lazy_optional { };
template <typename... Content> struct sequence { };
struct empty { };

template <typename... Content> struct plus { };
template <typename... Content> struct star { };
template <size_t a, size_t b, typename... Content> struct repeat { };

template <typename... Content> struct lazy_plus { };
template <typename... Content> struct lazy_star { };
template <size_t a, size_t b, typename... Content> struct lazy_repeat { };

template <typename... Content> struct possessive_plus { };
template <typename... Content> struct possessive_star { };
template <size_t a, size_t b, typename... Content> struct possessive_repeat { };

template <size_t Index, typename... Content> struct capture { };

template <size_t Index, typename Name, typename... Content> struct capture_with_name { };

template <size_t Index> struct back_reference { };
template <typename Name> struct back_reference_with_name { };

template <typename Type> struct look_start { };

template <typename... Content> struct lookahead_positive { };
template <typename... Content> struct lookahead_negative { };

struct assert_begin { };
struct assert_end { };

}

#endif

#ifndef CTRE__ATOMS_CHARACTERS__HPP
#define CTRE__ATOMS_CHARACTERS__HPP

#ifndef CTRE__UTILITY__HPP
#define CTRE__UTILITY__HPP

#ifdef _MSC_VER
#define CTRE_FORCE_INLINE __forceinline
#define CTRE_FLATTEN
#else
#define CTRE_FORCE_INLINE inline __attribute__((always_inline))
#define CTRE_FLATTEN __attribute__((flatten))
#endif

#endif
#include <cstdint>

namespace ctre {
	
// sfinae check for types here

template <typename T> class MatchesCharacter {
	template <typename Y, typename CharT> static auto test(CharT c) -> decltype(Y::match_char(c), std::true_type());
	template <typename> static auto test(...) -> std::false_type;
public:
	template <typename CharT> static inline constexpr bool value = decltype(test<T>(std::declval<CharT>()))();
};

template <auto V> struct character {
	template <typename CharT> CTRE_FORCE_INLINE static constexpr bool match_char(CharT value) noexcept {
		return value == V;
	}
};

struct any {
	template <typename CharT> CTRE_FORCE_INLINE static constexpr bool match_char(CharT) noexcept { return true; }
};

template <typename... Content> struct negative_set {
	template <typename CharT> inline static constexpr bool match_char(CharT value) noexcept {
		return !(Content::match_char(value) || ... || false);
	}
};

template <typename... Content> struct set {
	template <typename CharT> inline static constexpr bool match_char(CharT value) noexcept {
		return (Content::match_char(value) || ... || false);
	}
};

template <auto... Cs> struct enumeration : set<character<Cs>...> { };

template <typename... Content> struct negate {
	template <typename CharT> inline static constexpr bool match_char(CharT value) noexcept {
		return !(Content::match_char(value) || ... || false);
	}
};

template <auto A, auto B> struct char_range {
	template <typename CharT> CTRE_FORCE_INLINE static constexpr bool match_char(CharT value) noexcept {
		return (value >= A) && (value <= B);
	}
};

struct word_chars : set<char_range<'A','Z'>, char_range<'a','z'>, char_range<'0','9'>, character<'_'> > { };

struct space_chars : enumeration<' ', '\t', '\n', '\v', '\f', '\r'> {};

struct alphanum_chars : set<char_range<'A','Z'>, char_range<'a','z'>, char_range<'0','9'> > { };

struct alpha_chars : set<char_range<'A','Z'>, char_range<'a','z'> > { };

struct xdigit_chars : set<char_range<'A','F'>, char_range<'a','f'>, char_range<'0','9'> > { };

struct punct_chars
    : enumeration<'!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', ',', '-',
		  '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']',
		  '^', '_', '`', '{', '|', '}', '~'> {};

struct digit_chars : char_range<'0','9'> { };

struct ascii_chars : char_range<'\x00','\x7F'> { };

}

#endif

#ifndef CTRE__ATOMS_UNICODE__HPP
#define CTRE__ATOMS_UNICODE__HPP

// master branch is not including unicode db (for now)
// #include "../unicode-db/unicode.hpp"
#include <array>

namespace ctre {

// properties name & value

template <auto... Str> struct property_name { };
template <auto... Str> struct property_value { };

template <size_t Sz> constexpr std::string_view get_string_view(const std::array<char, Sz> & arr) noexcept {
	return std::string_view(arr.data(), arr.size());
}

// basic support for binary and type-value properties

template <auto Name> struct binary_property;
template <auto Name, auto Value> struct property;

// unicode TS#18 level 1.2 general_category
//template <uni::__binary_prop Property> struct binary_property<Property> {
//	template <typename CharT> inline static constexpr bool match_char(CharT) noexcept {
//		return uni::__get_binary_prop<Property>(c);
//	}
//};

// unicode TS#18 level 1.2.2

enum class property_type {
	script, script_extension, age, block, unknown
};

// unicode TS#18 level 1.2.2

//template <uni::script Script> struct binary_property<Script> {
//	template <typename CharT> inline static constexpr bool match_char(CharT) noexcept {
//		return uni::cp_script(c) == Script;
//	}
//};
//
//template <uni::script Script> struct property<property_type::script_extension, Script> {
//	template <typename CharT> inline static constexpr bool match_char(CharT c) noexcept {
//		for (uni::script sc: uni::cp_script_extensions(c)) {
//			if (sc == Script) return true;
//		}
//		return false;
//	}
//};

//template <uni::version Age> struct binary_property<Age> {
//	template <typename CharT> inline static constexpr bool match_char(CharT c) noexcept {
//		return uni::cp_age(c) <= Age;
//	}
//};
//
//template <uni::block Block> struct binary_property<Block> {
//	template <typename CharT> inline static constexpr bool match_char(CharT c) noexcept {
//		return uni::cp_block(c) == Block;
//	}
//};

// nonbinary properties

constexpr property_type property_type_from_name(std::string_view) noexcept {
	return property_type::unknown;
	//using namespace std::string_view_literals;
	//if (uni::__pronamecomp(str, "script"sv) == 0 || uni::__pronamecomp(str, "sc"sv) == 0) {
	//	return property_type::script;
	//} else if (uni::__pronamecomp(str, "script_extension"sv) == 0 || uni::__pronamecomp(str, "scx"sv) == 0) {
	//	return property_type::script_extension;
	//} else if (uni::__pronamecomp(str, "age"sv) == 0) {
	//	return property_type::age;
	//} else if (uni::__pronamecomp(str, "block"sv) == 0) {
	//	return property_type::block;
	//} else {
	//	return property_type::unknown;
	//}
}

template <property_type Property> struct property_type_builder {
	template <auto... Value> static constexpr auto get() {
		return ctll::reject{};
	}
};

template <auto... Name> struct property_builder {
	static constexpr std::array<char, sizeof...(Name)> name{static_cast<char>(Name)...};
	static constexpr property_type type = property_type_from_name(get_string_view(name));
	
	using helper = property_type_builder<type>;
	
	template <auto... Value> static constexpr auto get() {
		return helper::template get<Value...>();
	}
};

// unicode TS#18 level 1.2.2 script support

//template <> struct property_type_builder<property_type::script> {
//	template <auto... Value> static constexpr auto get() {
//		constexpr std::array<char, sizeof...(Value)> value{Value...};
//		constexpr auto sc = uni::__script_from_string(get_string_view(value));
//		if constexpr (sc == uni::script::unknown) {
//			return ctll::reject{};
//		} else {
//			return binary_property<sc>();
//		}
//	}
//};
//
//template <> struct property_type_builder<property_type::script_extension> {
//	template <auto... Value> static constexpr auto get() {
//		constexpr std::array<char, sizeof...(Value)> value{Value...};
//		constexpr auto sc = uni::__script_from_string(get_string_view(value));
//		if constexpr (sc == uni::script::unknown) {
//			return ctll::reject{};
//		} else {
//			return property<property_type::script_extension, sc>();
//		}
//	}
//};
//
//template <> struct property_type_builder<property_type::age> {
//	template <auto... Value> static constexpr auto get() {
//		constexpr std::array<char, sizeof...(Value)> value{Value...};
//		constexpr auto age = uni::__age_from_string(get_string_view(value));
//		if constexpr (age == uni::version::unassigned) {
//			return ctll::reject{};
//		} else {
//			return binary_property<age>();
//		}
//	}
//};
//
//template <> struct property_type_builder<property_type::block> {
//	template <auto... Value> static constexpr auto get() {
//		constexpr std::array<char, sizeof...(Value)> value{Value...};
//		constexpr auto block = uni::__block_from_string(get_string_view(value));
//		if constexpr (block == uni::block::no_block) {
//			return ctll::reject{};
//		} else {
//			return binary_property<block>();
//		}
//	}
//};

}

#endif 

#ifndef CTRE__ID__HPP
#define CTRE__ID__HPP

#include <type_traits>

namespace ctre {
	
template <auto... Name> struct id {
	static constexpr auto name = ctll::fixed_string<sizeof...(Name)>{{Name...}};
};
	
template <auto... Name> constexpr auto operator==(id<Name...>, id<Name...>) noexcept -> std::true_type { return {}; }

template <auto... Name1, auto... Name2> constexpr auto operator==(id<Name1...>, id<Name2...>) noexcept -> std::false_type { return {}; }
	
template <auto... Name, typename T> constexpr auto operator==(id<Name...>, T) noexcept -> std::false_type { return {}; }

}

#endif
#include <cstdint>
#include <limits>

namespace ctre {
	
template <size_t Counter> struct pcre_parameters {
	static constexpr size_t current_counter = Counter;
};
	
template <typename Stack = ctll::list<>, typename Parameters = pcre_parameters<0>> struct pcre_context {
	using stack_type = Stack;
	using parameters_type = Parameters;
	static constexpr inline auto stack = stack_type();
	static constexpr inline auto parameters = parameters_type();
	constexpr pcre_context() noexcept { }
	constexpr pcre_context(Stack, Parameters) noexcept { }
};

template <typename... Content, typename Parameters> pcre_context(ctll::list<Content...>, Parameters) -> pcre_context<ctll::list<Content...>, Parameters>;
	
template <size_t Value> struct number { };

template <size_t Id> struct capture_id { };
	
struct pcre_actions {
// i know it's ugly, but it's more readable
#ifndef CTRE__ACTIONS__ASSERTS__HPP
#define CTRE__ACTIONS__ASSERTS__HPP

// push_assert_begin
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_assert_begin, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(assert_begin(), subject.stack), subject.parameters};
}

// push_assert_end
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_assert_end, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(assert_end(), subject.stack), subject.parameters};
}

#endif
	
#ifndef CTRE__ACTIONS__BACKREFERENCE__HPP
#define CTRE__ACTIONS__BACKREFERENCE__HPP

// backreference with name
template <auto... Str, auto V, typename... Ts, size_t Counter> static constexpr auto apply(pcre::make_back_reference, ctll::term<V>, pcre_context<ctll::list<id<Str...>, Ts...>, pcre_parameters<Counter>>) {	
	return pcre_context{ctll::push_front(back_reference_with_name<id<Str...>>(), ctll::list<Ts...>()), pcre_parameters<Counter>()};
}

// with just a number
template <auto V, size_t Id, typename... Ts, size_t Counter> static constexpr auto apply(pcre::make_back_reference, ctll::term<V>, pcre_context<ctll::list<number<Id>, Ts...>, pcre_parameters<Counter>>) {
	// if we are looking outside of existing list of Ids ... reject input during parsing
	if constexpr (Counter < Id) {
		return ctll::reject{};
	} else {
		return pcre_context{ctll::push_front(back_reference<Id>(), ctll::list<Ts...>()), pcre_parameters<Counter>()};
	}
}

// relative backreference
template <auto V, size_t Id, typename... Ts, size_t Counter> static constexpr auto apply(pcre::make_relative_back_reference, ctll::term<V>, [[maybe_unused]] pcre_context<ctll::list<number<Id>, Ts...>, pcre_parameters<Counter>>) {	
	// if we are looking outside of existing list of Ids ... reject input during parsing
	if constexpr (Counter < Id) {
		return ctll::reject{};
	} else {
		constexpr size_t absolute_id = (Counter + 1) - Id;
		return pcre_context{ctll::push_front(back_reference<absolute_id>(), ctll::list<Ts...>()), pcre_parameters<Counter>()};
	}
}

#endif

#ifndef CTRE__ACTIONS__CAPTURE__HPP
#define CTRE__ACTIONS__CAPTURE__HPP

// prepare_capture
template <auto V, typename... Ts, size_t Counter> static constexpr auto apply(pcre::prepare_capture, ctll::term<V>, pcre_context<ctll::list<Ts...>, pcre_parameters<Counter>>) {
	return pcre_context{ctll::push_front(capture_id<Counter+1>(), ctll::list<Ts...>()), pcre_parameters<Counter+1>()};
}

// reset_capture
template <auto V, typename... Ts, size_t Id, size_t Counter> static constexpr auto apply(pcre::reset_capture, ctll::term<V>, pcre_context<ctll::list<capture_id<Id>, Ts...>, pcre_parameters<Counter>>) {
	return pcre_context{ctll::list<Ts...>(), pcre_parameters<Counter-1>()};
}

// capture
template <auto V, typename A, size_t Id, typename... Ts, size_t Counter> static constexpr auto apply(pcre::make_capture, ctll::term<V>, pcre_context<ctll::list<A, capture_id<Id>, Ts...>, pcre_parameters<Counter>>) {
	return pcre_context{ctll::push_front(capture<Id, A>(), ctll::list<Ts...>()), pcre_parameters<Counter>()};
}
// capture (sequence)
template <auto V, typename... Content, size_t Id, typename... Ts, size_t Counter> static constexpr auto apply(pcre::make_capture, ctll::term<V>, pcre_context<ctll::list<sequence<Content...>, capture_id<Id>, Ts...>, pcre_parameters<Counter>>) {
	return pcre_context{ctll::push_front(capture<Id, Content...>(), ctll::list<Ts...>()), pcre_parameters<Counter>()};
}
// push_name
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_name, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(id<V>(), subject.stack), subject.parameters};
}
// push_name (concat)
template <auto... Str, auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_name, ctll::term<V>, pcre_context<ctll::list<id<Str...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(id<Str..., V>(), ctll::list<Ts...>()), subject.parameters};
}
// capture with name
template <auto... Str, auto V, typename A, size_t Id, typename... Ts, size_t Counter> static constexpr auto apply(pcre::make_capture_with_name, ctll::term<V>, pcre_context<ctll::list<A, id<Str...>, capture_id<Id>, Ts...>, pcre_parameters<Counter>>) {
	return pcre_context{ctll::push_front(capture_with_name<Id, id<Str...>, A>(), ctll::list<Ts...>()), pcre_parameters<Counter>()};
}
// capture with name (sequence)
template <auto... Str, auto V, typename... Content, size_t Id, typename... Ts, size_t Counter> static constexpr auto apply(pcre::make_capture_with_name, ctll::term<V>, pcre_context<ctll::list<sequence<Content...>, id<Str...>, capture_id<Id>, Ts...>, pcre_parameters<Counter>>) {
	return pcre_context{ctll::push_front(capture_with_name<Id, id<Str...>, Content...>(), ctll::list<Ts...>()), pcre_parameters<Counter>()};
}

#endif

#ifndef CTRE__ACTIONS__CHARACTERS__HPP
#define CTRE__ACTIONS__CHARACTERS__HPP

// push character
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_character, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(character<V>(), subject.stack), subject.parameters};
}
// push_any_character
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_character_anything, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(any(), subject.stack), subject.parameters};
}
// character_alarm
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_character_alarm, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(character<'\x07'>(), subject.stack), subject.parameters};
}
// character_escape
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_character_escape, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(character<'\x14'>(), subject.stack), subject.parameters};
}
// character_formfeed
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_character_formfeed, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(character<'\x0C'>(), subject.stack), subject.parameters};
}
// push_character_newline
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_character_newline, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(character<'\x0A'>(), subject.stack), subject.parameters};
}
// push_character_null
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_character_null, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(character<'\0'>(), subject.stack), subject.parameters};
}
// push_character_return_carriage
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_character_return_carriage, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(character<'\x0D'>(), subject.stack), subject.parameters};
}
// push_character_tab
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_character_tab, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(character<'\x09'>(), subject.stack), subject.parameters};
}

#endif

#ifndef CTRE__ACTIONS__CLASS__HPP
#define CTRE__ACTIONS__CLASS__HPP

// class_digit
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_digit, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::set<ctre::digit_chars>(), subject.stack), subject.parameters};
}
// class_non_digit
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_nondigit, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::negative_set<ctre::digit_chars>(), subject.stack), subject.parameters};
}
// class_space
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_space, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::set<ctre::space_chars>(), subject.stack), subject.parameters};
}
// class_nonspace
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_nonspace, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::negative_set<ctre::space_chars>(), subject.stack), subject.parameters};
}
// class_word
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_word, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::set<ctre::word_chars>(), subject.stack), subject.parameters};
}
// class_nonword
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_nonword, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::negative_set<ctre::word_chars>(), subject.stack), subject.parameters};
}
// class_nonnewline
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_nonnewline, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::negative_set<character<'\n'>>(), subject.stack), subject.parameters};
}

#endif

#ifndef CTRE__ACTIONS__HEXDEC__HPP
#define CTRE__ACTIONS__HEXDEC__HPP

// hexdec character support (seed)
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::create_hexdec, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(number<0ull>(), subject.stack), subject.parameters};
}
// hexdec character support (push value)
template <auto V, size_t N, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_hexdec, ctll::term<V>, pcre_context<ctll::list<number<N>, Ts...>, Parameters> subject) {
	constexpr auto previous = N << 4ull;	
	if constexpr (V >= 'a' && V <= 'f') {
		return pcre_context{ctll::push_front(number<(previous + (V - 'a' + 10))>(), ctll::list<Ts...>()), subject.parameters};
	} else if constexpr (V >= 'A' && V <= 'F') {
		return pcre_context{ctll::push_front(number<(previous + (V - 'A' + 10))>(), ctll::list<Ts...>()), subject.parameters};
	} else {
		return pcre_context{ctll::push_front(number<(previous + (V - '0'))>(), ctll::list<Ts...>()), subject.parameters};
	}
}
// hexdec character support (convert to character)
template <auto V, size_t N, typename... Ts, typename Parameters> static constexpr auto apply(pcre::finish_hexdec, ctll::term<V>, pcre_context<ctll::list<number<N>, Ts...>, Parameters> subject) {
	if constexpr (N <= std::numeric_limits<unsigned char>::max()) {
		return pcre_context{ctll::push_front(character<(char)N>(), ctll::list<Ts...>()), subject.parameters};
	} else {
		return pcre_context{ctll::push_front(character<N>(), ctll::list<Ts...>()), subject.parameters};
	} 
}	

#endif

#ifndef CTRE__ACTIONS__LOOKAHEAD__HPP
#define CTRE__ACTIONS__LOOKAHEAD__HPP

// lookahead positive start
template <auto V, typename... Ts, size_t Counter> static constexpr auto apply(pcre::start_lookahead_positive, ctll::term<V>, pcre_context<ctll::list<Ts...>, pcre_parameters<Counter>>) {
	return pcre_context{ctll::list<look_start<lookahead_positive<>>, Ts...>(), pcre_parameters<Counter>()};
}

// lookahead positive end
template <auto V, typename Look, typename... Ts, size_t Counter> static constexpr auto apply(pcre::look_finish, ctll::term<V>, pcre_context<ctll::list<Look, look_start<lookahead_positive<>>, Ts...>, pcre_parameters<Counter>>) {
	return pcre_context{ctll::list<lookahead_positive<Look>, Ts...>(), pcre_parameters<Counter>()};
}

// lookahead positive end (sequence)
template <auto V, typename... Look, typename... Ts, size_t Counter> static constexpr auto apply(pcre::look_finish, ctll::term<V>, pcre_context<ctll::list<ctre::sequence<Look...>, look_start<lookahead_positive<>>, Ts...>, pcre_parameters<Counter>>) {
	return pcre_context{ctll::list<lookahead_positive<Look...>, Ts...>(), pcre_parameters<Counter>()};
}

// lookahead negative start
template <auto V, typename... Ts, size_t Counter> static constexpr auto apply(pcre::start_lookahead_negative, ctll::term<V>, pcre_context<ctll::list<Ts...>, pcre_parameters<Counter>>) {
	return pcre_context{ctll::list<look_start<lookahead_negative<>>, Ts...>(), pcre_parameters<Counter>()};
}

// lookahead negative end
template <auto V, typename Look, typename... Ts, size_t Counter> static constexpr auto apply(pcre::look_finish, ctll::term<V>, pcre_context<ctll::list<Look, look_start<lookahead_negative<>>, Ts...>, pcre_parameters<Counter>>) {
	return pcre_context{ctll::list<lookahead_negative<Look>, Ts...>(), pcre_parameters<Counter>()};
}

// lookahead negative end (sequence)
template <auto V, typename... Look, typename... Ts, size_t Counter> static constexpr auto apply(pcre::look_finish, ctll::term<V>, pcre_context<ctll::list<ctre::sequence<Look...>, look_start<lookahead_negative<>>, Ts...>, pcre_parameters<Counter>>) {
	return pcre_context{ctll::list<lookahead_negative<Look...>, Ts...>(), pcre_parameters<Counter>()};
}

#endif

#ifndef CTRE__ACTIONS__NAMED_CLASS__HPP
#define CTRE__ACTIONS__NAMED_CLASS__HPP

// class_named_alnum
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_alnum, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::alphanum_chars(), subject.stack), subject.parameters};
}
// class_named_alpha
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_alpha, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::alpha_chars(), subject.stack), subject.parameters};
}
// class_named_digit
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_digit, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::digit_chars(), subject.stack), subject.parameters};
}
// class_named_ascii
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_ascii, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::ascii_chars(), subject.stack), subject.parameters};
}
// class_named_blank
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_blank, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::enumeration<' ','\t'>(), subject.stack), subject.parameters};
}
// class_named_cntrl
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_cntrl, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::set<ctre::char_range<'\x00','\x1F'>, ctre::character<'\x7F'>>(), subject.stack), subject.parameters};
}
// class_named_graph
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_graph, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::char_range<'\x21','\x7E'>(), subject.stack), subject.parameters};
}
// class_named_lower
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_lower, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::char_range<'a','z'>(), subject.stack), subject.parameters};
}
// class_named_upper
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_upper, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::char_range<'A','Z'>(), subject.stack), subject.parameters};
}
// class_named_print
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_print, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(ctre::char_range<'\x20','\x7E'>(), subject.stack), subject.parameters};
}
// class_named_space
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_space, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(space_chars(), subject.stack), subject.parameters};
}
// class_named_word
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_word, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(word_chars(), subject.stack), subject.parameters};
}
// class_named_punct
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_punct, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(punct_chars(), subject.stack), subject.parameters};
}
// class_named_xdigit
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::class_named_xdigit, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(xdigit_chars(), subject.stack), subject.parameters};
}

#endif

#ifndef CTRE__ACTIONS__OPTIONS__HPP
#define CTRE__ACTIONS__OPTIONS__HPP

// empty option for alternate
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_empty, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(empty(), subject.stack), subject.parameters};
}

// empty option for empty regex
template <typename Parameters> static constexpr auto apply(pcre::push_empty, ctll::epsilon, pcre_context<ctll::list<>, Parameters> subject) {
	return pcre_context{ctll::push_front(empty(), subject.stack), subject.parameters};
}

// make_alternate (A|B)
template <auto V, typename A, typename B, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_alternate, ctll::term<V>, pcre_context<ctll::list<B, A, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(select<A,B>(), ctll::list<Ts...>()), subject.parameters};
}
// make_alternate (As..)|B => (As..|B)
template <auto V, typename A, typename... Bs, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_alternate, ctll::term<V>, pcre_context<ctll::list<ctre::select<Bs...>, A, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(select<A,Bs...>(), ctll::list<Ts...>()), subject.parameters};
}

// make_optional
template <auto V, typename A, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_optional, ctll::term<V>, pcre_context<ctll::list<A, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(optional<A>(), ctll::list<Ts...>()), subject.parameters};
}

template <auto V, typename... Content, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_optional, ctll::term<V>, pcre_context<ctll::list<sequence<Content...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(optional<Content...>(), ctll::list<Ts...>()), subject.parameters};
}

// make_lazy (optional)
template <auto V, typename... Subject, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_lazy, ctll::term<V>, pcre_context<ctll::list<optional<Subject...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(lazy_optional<Subject...>(), ctll::list<Ts...>()), subject.parameters};
}

#endif

#ifndef CTRE__ACTIONS__REPEAT__HPP
#define CTRE__ACTIONS__REPEAT__HPP

// repeat 1..N
template <auto V, typename A, typename... Ts, typename Parameters> static constexpr auto apply(pcre::repeat_plus, ctll::term<V>, pcre_context<ctll::list<A, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(plus<A>(), ctll::list<Ts...>()), subject.parameters};
}
// repeat 1..N (sequence)
template <auto V, typename... Content, typename... Ts, typename Parameters> static constexpr auto apply(pcre::repeat_plus, ctll::term<V>, pcre_context<ctll::list<sequence<Content...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(plus<Content...>(), ctll::list<Ts...>()), subject.parameters};
}

// repeat 0..N
template <auto V, typename A, typename... Ts, typename Parameters> static constexpr auto apply(pcre::repeat_star, ctll::term<V>, pcre_context<ctll::list<A, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(star<A>(), ctll::list<Ts...>()), subject.parameters};
}
// repeat 0..N (sequence)
template <auto V, typename... Content, typename... Ts, typename Parameters> static constexpr auto apply(pcre::repeat_star, ctll::term<V>, pcre_context<ctll::list<sequence<Content...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(star<Content...>(), ctll::list<Ts...>()), subject.parameters};
}

// create_number (seed)
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::create_number, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(number<static_cast<size_t>(V - '0')>(), subject.stack), subject.parameters};
}
// push_number
template <auto V, size_t N, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_number, ctll::term<V>, pcre_context<ctll::list<number<N>, Ts...>, Parameters> subject) {
	constexpr size_t previous = N * 10ull;	
	return pcre_context{ctll::push_front(number<(previous + (V - '0'))>(), ctll::list<Ts...>()), subject.parameters};
}

// repeat A..B
template <auto V, typename Subject, size_t A, size_t B, typename... Ts, typename Parameters> static constexpr auto apply(pcre::repeat_ab, ctll::term<V>, pcre_context<ctll::list<number<B>, number<A>, Subject, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(repeat<A,B,Subject>(), ctll::list<Ts...>()), subject.parameters};
}
// repeat A..B (sequence)
template <auto V, typename... Content, size_t A, size_t B, typename... Ts, typename Parameters> static constexpr auto apply(pcre::repeat_ab, ctll::term<V>, pcre_context<ctll::list<number<B>, number<A>, sequence<Content...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(repeat<A,B,Content...>(), ctll::list<Ts...>()), subject.parameters};
}

// repeat_exactly 
template <auto V, typename Subject, size_t A, typename... Ts, typename Parameters> static constexpr auto apply(pcre::repeat_exactly, ctll::term<V>, pcre_context<ctll::list<number<A>, Subject, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(repeat<A,A,Subject>(), ctll::list<Ts...>()), subject.parameters};
}
// repeat_exactly A..B (sequence)
template <auto V, typename... Content, size_t A, typename... Ts, typename Parameters> static constexpr auto apply(pcre::repeat_exactly, ctll::term<V>, pcre_context<ctll::list<number<A>, sequence<Content...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(repeat<A,A,Content...>(), ctll::list<Ts...>()), subject.parameters};
}

// repeat_at_least (A+) 
template <auto V, typename Subject, size_t A, typename... Ts, typename Parameters> static constexpr auto apply(pcre::repeat_at_least, ctll::term<V>, pcre_context<ctll::list<number<A>, Subject, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(repeat<A,0,Subject>(), ctll::list<Ts...>()), subject.parameters};
}
// repeat_at_least (A+) (sequence)
template <auto V, typename... Content, size_t A, typename... Ts, typename Parameters> static constexpr auto apply(pcre::repeat_at_least, ctll::term<V>, pcre_context<ctll::list<number<A>, sequence<Content...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(repeat<A,0,Content...>(), ctll::list<Ts...>()), subject.parameters};
}

// make_lazy (plus)
template <auto V, typename... Subject, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_lazy, ctll::term<V>, pcre_context<ctll::list<plus<Subject...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(lazy_plus<Subject...>(), ctll::list<Ts...>()), subject.parameters};
}

// make_lazy (star)
template <auto V, typename... Subject, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_lazy, ctll::term<V>, pcre_context<ctll::list<star<Subject...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(lazy_star<Subject...>(), ctll::list<Ts...>()), subject.parameters};
}

// make_lazy (repeat<A,B>)
template <auto V, typename... Subject, size_t A, size_t B, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_lazy, ctll::term<V>, pcre_context<ctll::list<repeat<A,B,Subject...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(lazy_repeat<A,B,Subject...>(), ctll::list<Ts...>()), subject.parameters};
}

// make_possessive (plus)
template <auto V, typename... Subject, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_possessive, ctll::term<V>, pcre_context<ctll::list<plus<Subject...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(possessive_plus<Subject...>(), ctll::list<Ts...>()), subject.parameters};
}

// make_possessive (star)
template <auto V, typename... Subject, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_possessive, ctll::term<V>, pcre_context<ctll::list<star<Subject...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(possessive_star<Subject...>(), ctll::list<Ts...>()), subject.parameters};
}

// make_possessive (repeat<A,B>)
template <auto V, typename... Subject, size_t A, size_t B, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_possessive, ctll::term<V>, pcre_context<ctll::list<repeat<A,B,Subject...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(possessive_repeat<A,B,Subject...>(), ctll::list<Ts...>()), subject.parameters};
}

#endif

#ifndef CTRE__ACTIONS__SEQUENCE__HPP
#define CTRE__ACTIONS__SEQUENCE__HPP

// make_sequence
template <auto V, typename A, typename B, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_sequence, ctll::term<V>, pcre_context<ctll::list<B,A,Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(sequence<A,B>(), ctll::list<Ts...>()), subject.parameters};
}
// make_sequence (concat)
template <auto V, typename... As, typename B, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_sequence, ctll::term<V>, pcre_context<ctll::list<sequence<As...>,B,Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(sequence<B,As...>(), ctll::list<Ts...>()), subject.parameters};
}
// make_sequence (make string)
template <auto V, auto A, auto B, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_sequence, ctll::term<V>, pcre_context<ctll::list<character<B>,character<A>,Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(string<A,B>(), ctll::list<Ts...>()), subject.parameters};
}
// make_sequence (concat string)
template <auto V, auto... As, auto B, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_sequence, ctll::term<V>, pcre_context<ctll::list<string<As...>,character<B>,Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(string<B,As...>(), ctll::list<Ts...>()), subject.parameters};
}

#endif

#ifndef CTRE__ACTIONS__SET__HPP
#define CTRE__ACTIONS__SET__HPP

// UTILITY
// add into set if not exists
template <template <typename...> typename SetType, typename T, typename... As, bool Exists = (std::is_same_v<T, As> || ... || false)> static constexpr auto push_back_into_set(T, SetType<As...>) -> ctll::conditional<Exists, SetType<As...>, SetType<As...,T>> { return {}; }

//template <template <typename...> typename SetType, typename A, typename BHead, typename... Bs> struct set_merge_helper {
//	using step = decltype(push_back_into_set<SetType>(BHead(), A()));
//	using type = ctll::conditional<(sizeof...(Bs) > 0), set_merge_helper<SetType, step, Bs...>, step>;
//};
//
//// add set into set if not exists
//template <template <typename...> typename SetType, typename... As, typename... Bs> static constexpr auto push_back_into_set(SetType<As...>, SetType<Bs...>) -> typename set_merge_helper<SetType, SetType<As...>, Bs...>::type { return pcre_context{{};), subject.parameters}}
//
//template <template <typename...> typename SetType, typename... As> static constexpr auto push_back_into_set(SetType<As...>, SetType<>) -> SetType<As...> { return pcre_context{{};), subject.parameters}}

// END OF UTILITY

// set_start
template <auto V, typename A,typename... Ts, typename Parameters> static constexpr auto apply(pcre::set_start, ctll::term<V>, pcre_context<ctll::list<A,Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(set<A>(), ctll::list<Ts...>()), subject.parameters};
}
// set_make
template <auto V, typename... Content, typename... Ts, typename Parameters> static constexpr auto apply(pcre::set_make, ctll::term<V>, pcre_context<ctll::list<set<Content...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(set<Content...>(), ctll::list<Ts...>()), subject.parameters};
}
// set_make_negative
template <auto V, typename... Content, typename... Ts, typename Parameters> static constexpr auto apply(pcre::set_make_negative, ctll::term<V>, pcre_context<ctll::list<set<Content...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(negative_set<Content...>(), ctll::list<Ts...>()), subject.parameters};
}
// set{A...} + B = set{A,B}
template <auto V, typename A, typename... Content, typename... Ts, typename Parameters> static constexpr auto apply(pcre::set_combine, ctll::term<V>, pcre_context<ctll::list<A,set<Content...>,Ts...>, Parameters> subject) {
	auto new_set = push_back_into_set<set>(A(), set<Content...>());
	return pcre_context{ctll::push_front(new_set, ctll::list<Ts...>()), subject.parameters};
}
// TODO checkme
//// set{A...} + set{B...} = set{A...,B...}
//template <auto V, typename... As, typename... Bs, typename... Ts, typename Parameters> static constexpr auto apply(pcre::set_combine, ctll::term<V>, pcre_context<ctll::list<set<As...>,set<Bs...>,Ts...>, Parameters> subject) {
//	auto new_set = push_back_into_set<set>(set<As...>(), set<Bs...>());
//	return pcre_context{ctll::push_front(new_set, ctll::list<Ts...>()), subject.parameters};
//}

// negative_set{A...} + B = negative_set{A,B}
template <auto V, typename A, typename... Content, typename... Ts, typename Parameters> static constexpr auto apply(pcre::set_combine, ctll::term<V>, pcre_context<ctll::list<A,negative_set<Content...>,Ts...>, Parameters> subject) {
	auto new_set = push_back_into_set<set>(A(), set<Content...>());
	return pcre_context{ctll::push_front(new_set, ctll::list<Ts...>()), subject.parameters};
}
// TODO checkme
//// negative_set{A...} + negative_set{B...} = negative_set{A...,B...}
//template <auto V, typename... As, typename... Bs, typename... Ts, typename Parameters> static constexpr auto apply(pcre::set_combine, ctll::term<V>, pcre_context<ctll::list<negative_set<As...>,negative_set<Bs...>,Ts...>, Parameters> subject) {
//	auto new_set = push_back_into_set<negative_set>(negative_set<As...>(), negative_set<Bs...>());
//	return pcre_context{ctll::push_front(new_set, ctll::list<Ts...>()), subject.parameters};
//}
// negate_class_named: [[^:digit:]] = [^[:digit:]]
template <auto V, typename A, typename... Ts, typename Parameters> static constexpr auto apply(pcre::negate_class_named, ctll::term<V>, pcre_context<ctll::list<A, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(negate<A>(), ctll::list<Ts...>()), subject.parameters};
}

// add range to set
template <auto V, auto B, auto A, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_range, ctll::term<V>, pcre_context<ctll::list<character<B>,character<A>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(char_range<A,B>(), ctll::list<Ts...>()), subject.parameters};
}

#endif
	
#ifndef CTRE__ACTIONS__PROPERTIES__HPP
#define CTRE__ACTIONS__PROPERTIES__HPP

// push_property_name
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_property_name, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(property_name<V>(), subject.stack), subject.parameters};
}
// push_property_name (concat)
template <auto... Str, auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_property_name, ctll::term<V>, pcre_context<ctll::list<property_name<Str...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(property_name<Str..., V>(), ctll::list<Ts...>()), subject.parameters};
}

// push_property_value
template <auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_property_value, ctll::term<V>, pcre_context<ctll::list<Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(property_value<V>(), subject.stack), subject.parameters};
}
// push_property_value (concat)
template <auto... Str, auto V, typename... Ts, typename Parameters> static constexpr auto apply(pcre::push_property_value, ctll::term<V>, pcre_context<ctll::list<property_value<Str...>, Ts...>, Parameters> subject) {
	return pcre_context{ctll::push_front(property_value<Str..., V>(), ctll::list<Ts...>()), subject.parameters};
}

// make_property
template <auto V, auto... Name, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_property, ctll::term<V>, [[maybe_unused]] pcre_context<ctll::list<property_name<Name...>, Ts...>, Parameters> subject) {
	return ctll::reject{};
	//constexpr std::array<char, sizeof...(Name)> name{static_cast<char>(Name)...};
	//constexpr auto p = uni::__binary_prop_from_string(get_string_view(name));
    //
	//if constexpr (p == uni::__binary_prop::unknown) {
	//	return ctll::reject{};
	//} else {
	//	return pcre_context{ctll::push_front(binary_property<p>(), ctll::list<Ts...>()), subject.parameters};
	//}
}

// make_property
template <auto V, auto... Value, auto... Name, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_property, ctll::term<V>, [[maybe_unused]] pcre_context<ctll::list<property_value<Value...>, property_name<Name...>, Ts...>, Parameters> subject) {
	return ctll::reject{};
	//constexpr auto prop = property_builder<Name...>::template get<Value...>();
	//
	//if constexpr (std::is_same_v<decltype(prop), ctll::reject>) {
	//	return ctll::reject{};
	//} else {
	//	return pcre_context{ctll::push_front(prop, ctll::list<Ts...>()), subject.parameters};
	//}
}

// make_property_negative
template <auto V, auto... Name, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_property_negative, ctll::term<V>, [[maybe_unused]] pcre_context<ctll::list<property_name<Name...>, Ts...>, Parameters> subject) {
	return ctll::reject{};
	//constexpr std::array<char, sizeof...(Name)> name{static_cast<char>(Name)...};
	//constexpr auto p = uni::__binary_prop_from_string(get_string_view(name));
    //
	//if constexpr (p == uni::__binary_prop::unknown) {
	//	return ctll::reject{};
	//} else {
	//	return pcre_context{ctll::push_front(negate<binary_property<p>>(), ctll::list<Ts...>()), subject.parameters};
	//}
}

// make_property_negative
template <auto V, auto... Value, auto... Name, typename... Ts, typename Parameters> static constexpr auto apply(pcre::make_property_negative, ctll::term<V>, [[maybe_unused]] pcre_context<ctll::list<property_value<Value...>, property_name<Name...>, Ts...>, Parameters> subject) {
	return ctll::reject{};
	//constexpr auto prop = property_builder<Name...>::template get<Value...>();
	//
	//if constexpr (std::is_same_v<decltype(prop), ctll::reject>) {
	//	return ctll::reject{};
	//} else {
	//	return pcre_context{ctll::push_front(negate<decltype(prop)>(), ctll::list<Ts...>()), subject.parameters};
	//}
}

#endif

};

}

#endif

#ifndef CTRE__EVALUATION__HPP
#define CTRE__EVALUATION__HPP

#ifndef CTRE__RETURN_TYPE__HPP
#define CTRE__RETURN_TYPE__HPP

#include <type_traits>
#include <tuple>
#include <string_view>
#include <string>

namespace ctre {
	
struct not_matched_tag_t { };

static constexpr inline auto not_matched = not_matched_tag_t{};
	
template <size_t Id, typename Name = void> struct captured_content {
	template <typename Iterator> class storage {
		Iterator _begin{};
		Iterator _end{};
		
		bool _matched{false};
	public:
		using char_type = typename std::iterator_traits<Iterator>::value_type;
		
		using name = Name;
	
		constexpr CTRE_FORCE_INLINE storage() noexcept {}
	
		constexpr CTRE_FORCE_INLINE void matched() noexcept {
			_matched = true;
		}
		constexpr CTRE_FORCE_INLINE void unmatch() noexcept {
			_matched = false;
		}
		constexpr CTRE_FORCE_INLINE void set_start(Iterator pos) noexcept {
			_begin = pos;
		}
		constexpr CTRE_FORCE_INLINE storage & set_end(Iterator pos) noexcept {
			_end = pos;
			return *this;
		}
		constexpr CTRE_FORCE_INLINE Iterator get_end() const noexcept {
			return _end;
		}
		
	
		constexpr auto begin() const noexcept {
			return _begin;
		}
		constexpr auto end() const noexcept {
			return _end;
		}
	
		constexpr CTRE_FORCE_INLINE operator bool() const noexcept {
			return _matched;
		}

		constexpr CTRE_FORCE_INLINE auto size() const noexcept {
			return static_cast<size_t>(std::distance(_begin, _end));
		}

		constexpr CTRE_FORCE_INLINE auto to_view() const noexcept {
			return std::basic_string_view<char_type>(&*_begin, static_cast<size_t>(std::distance(_begin, _end)));
		}
		
		constexpr CTRE_FORCE_INLINE auto to_string() const noexcept {
			return std::basic_string<char_type>(begin(), end());
		}
		
		constexpr CTRE_FORCE_INLINE operator std::basic_string_view<char_type>() const noexcept {
			return to_view();
		}
		
		constexpr CTRE_FORCE_INLINE explicit operator std::basic_string<char_type>() const noexcept {
			return to_string();
		}
		
		constexpr CTRE_FORCE_INLINE static size_t get_id() noexcept {
			return Id;
		}
	};
};

struct capture_not_exists_tag { };

static constexpr inline auto capture_not_exists = capture_not_exists_tag{};

template <typename... Captures> struct captures;

template <typename Head, typename... Tail> struct captures<Head, Tail...>: captures<Tail...> {
	Head head{};
	constexpr CTRE_FORCE_INLINE captures() noexcept { }
	template <size_t id> CTRE_FORCE_INLINE static constexpr bool exists() noexcept {
		if constexpr (id == Head::get_id()) {
			return true;
		} else {
			return captures<Tail...>::template exists<id>();
		}
	}
	template <typename Name> CTRE_FORCE_INLINE static constexpr bool exists() noexcept {
		if constexpr (std::is_same_v<Name, typename Head::name>) {
			return true;
		} else {
			return captures<Tail...>::template exists<Name>();
		}
	}
#if __cpp_nontype_template_parameter_class
	template <ctll::fixed_string Name> CTRE_FORCE_INLINE static constexpr bool exists() noexcept {
		if constexpr (std::is_same_v<typename Head::name, void>) {
			return captures<Tail...>::template exists<Name>();
		} else {
			if constexpr (Head::name::name.is_same_as(Name)) {
				return true;
			} else {
				return captures<Tail...>::template exists<Name>();
			}
		}
	}
#endif
	template <size_t id> CTRE_FORCE_INLINE constexpr auto & select() noexcept {
		if constexpr (id == Head::get_id()) {
			return head;
		} else {
			return captures<Tail...>::template select<id>();
		}
	}
	template <typename Name> CTRE_FORCE_INLINE constexpr auto & select() noexcept {
		if constexpr (std::is_same_v<Name, typename Head::name>) {
			return head;
		} else {
			return captures<Tail...>::template select<Name>();
		}
	}
	template <size_t id> CTRE_FORCE_INLINE constexpr auto & select() const noexcept {
		if constexpr (id == Head::get_id()) {
			return head;
		} else {
			return captures<Tail...>::template select<id>();
		}
	}
	template <typename Name> CTRE_FORCE_INLINE constexpr auto & select() const noexcept {
		if constexpr (std::is_same_v<Name, typename Head::name>) {
			return head;
		} else {
			return captures<Tail...>::template select<Name>();
		}
	}
#if __cpp_nontype_template_parameter_class
	template <ctll::fixed_string Name> CTRE_FORCE_INLINE constexpr auto & select() const noexcept {
		if constexpr (std::is_same_v<typename Head::name, void>) {
			return captures<Tail...>::template select<Name>();
		} else {
			if constexpr (Head::name::name.is_same_as(Name)) {
				return head;
			} else {
				return captures<Tail...>::template select<Name>();
			}
		}
	}
#endif
};

template <> struct captures<> {
	constexpr CTRE_FORCE_INLINE captures() noexcept { }
	template <size_t> CTRE_FORCE_INLINE static constexpr bool exists() noexcept {
		return false;
	}
	template <typename> CTRE_FORCE_INLINE static constexpr bool exists() noexcept {
		return false;
	}
#if __cpp_nontype_template_parameter_class
	template <ctll::fixed_string> CTRE_FORCE_INLINE static constexpr bool exists() noexcept {
		return false;
	}
#endif
	template <size_t> CTRE_FORCE_INLINE constexpr auto & select() const noexcept {
		return capture_not_exists;
	}
	template <typename> CTRE_FORCE_INLINE constexpr auto & select() const noexcept {
		return capture_not_exists;
	}
#if __cpp_nontype_template_parameter_class
	template <ctll::fixed_string> CTRE_FORCE_INLINE constexpr auto & select() const noexcept {
		return capture_not_exists;
	}
#endif
};

template <typename Iterator, typename... Captures> class regex_results {
	captures<captured_content<0>::template storage<Iterator>, typename Captures::template storage<Iterator>...> _captures{};
public:
	using char_type = typename std::iterator_traits<Iterator>::value_type;
	
	constexpr CTRE_FORCE_INLINE regex_results() noexcept { }
	constexpr CTRE_FORCE_INLINE regex_results(not_matched_tag_t) noexcept { }
	
	// special constructor for deducting
	constexpr CTRE_FORCE_INLINE regex_results(Iterator, ctll::list<Captures...>) noexcept { }
	
	template <size_t Id, typename = std::enable_if_t<decltype(_captures)::template exists<Id>()>> CTRE_FORCE_INLINE constexpr auto get() const noexcept {
		return _captures.template select<Id>();
	}
	template <typename Name, typename = std::enable_if_t<decltype(_captures)::template exists<Name>()>> CTRE_FORCE_INLINE constexpr auto get() const noexcept {
		return _captures.template select<Name>();
	}
#if __cpp_nontype_template_parameter_class
	template <ctll::fixed_string Name, typename = std::enable_if_t<decltype(_captures)::template exists<Name>()>> CTRE_FORCE_INLINE constexpr auto get() const noexcept {
		return _captures.template select<Name>();
	}
#endif
	static constexpr size_t size() noexcept {
		return sizeof...(Captures) + 1;
	}
	constexpr CTRE_FORCE_INLINE regex_results & matched() noexcept {
		_captures.template select<0>().matched();
		return *this;
	}
	constexpr CTRE_FORCE_INLINE regex_results & unmatch() noexcept {
		_captures.template select<0>().unmatch();
		return *this;
	}
	constexpr CTRE_FORCE_INLINE operator bool() const noexcept {
		return bool(_captures.template select<0>());
	}
	
	constexpr CTRE_FORCE_INLINE operator std::basic_string_view<char_type>() const noexcept {
		return to_view();
	}
	
	constexpr CTRE_FORCE_INLINE explicit operator std::basic_string<char_type>() const noexcept {
		return to_string();
	}
	
	constexpr CTRE_FORCE_INLINE auto to_view() const noexcept {
		return _captures.template select<0>().to_view();
	}
	
	constexpr CTRE_FORCE_INLINE auto to_string() const noexcept {
		return _captures.template select<0>().to_string();
	}
	
	constexpr CTRE_FORCE_INLINE regex_results & set_start_mark(Iterator pos) noexcept {
		_captures.template select<0>().set_start(pos);
		return *this;
	}
	constexpr CTRE_FORCE_INLINE regex_results & set_end_mark(Iterator pos) noexcept {
		_captures.template select<0>().set_end(pos);
		return *this;
	}
	constexpr CTRE_FORCE_INLINE Iterator get_end_position() const noexcept {
		return _captures.template select<0>().get_end();
	}
	template <size_t Id> CTRE_FORCE_INLINE constexpr regex_results & start_capture(Iterator pos) noexcept {
		_captures.template select<Id>().set_start(pos);
		return *this;
	}
	template <size_t Id> CTRE_FORCE_INLINE constexpr regex_results & end_capture(Iterator pos) noexcept {
		_captures.template select<Id>().set_end(pos).matched();
		return *this;
	}
};

template <typename Iterator, typename... Captures> regex_results(Iterator, ctll::list<Captures...>) -> regex_results<Iterator, Captures...>;

}

// support for structured bindings

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wmismatched-tags"
#endif

namespace std {
	template <typename... Captures> struct tuple_size<ctre::regex_results<Captures...>> : public std::integral_constant<size_t, ctre::regex_results<Captures...>::size()> { };
	
	template <size_t N, typename... Captures> struct tuple_element<N, ctre::regex_results<Captures...>> {
	public:
		using type = decltype(
			std::declval<const ctre::regex_results<Captures...> &>().template get<N>()
		);
	};
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#endif

#ifndef CTRE__FIND_CAPTURES__HPP
#define CTRE__FIND_CAPTURES__HPP

namespace ctre {

template <typename Pattern> constexpr auto find_captures(Pattern) noexcept {
	return find_captures(ctll::list<Pattern>(), ctll::list<>());
}

template <typename... Output> constexpr auto find_captures(ctll::list<>, ctll::list<Output...> output) noexcept {
	return output;
}

template <auto... String, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<string<String...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Tail...>(), output);
}

template <typename... Options, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<select<Options...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Options..., Tail...>(), output);
}

template <typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<optional<Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<lazy_optional<Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<sequence<Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <typename... Tail, typename Output> constexpr auto find_captures(ctll::list<empty, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Tail...>(), output);
}

template <typename... Tail, typename Output> constexpr auto find_captures(ctll::list<assert_begin, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Tail...>(), output);
}

template <typename... Tail, typename Output> constexpr auto find_captures(ctll::list<assert_end, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Tail...>(), output);
}

// , typename = std::enable_if_t<(MatchesCharacter<CharacterLike>::template value<char>)
template <typename CharacterLike, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<CharacterLike, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Tail...>(), output);
}

template <typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<plus<Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<star<Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <size_t A, size_t B, typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<repeat<A,B,Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<lazy_plus<Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<lazy_star<Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <size_t A, size_t B, typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<lazy_repeat<A,B,Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<possessive_plus<Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<possessive_star<Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <size_t A, size_t B, typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<possessive_repeat<A,B,Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<lookahead_positive<Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <typename... Content, typename... Tail, typename Output> constexpr auto find_captures(ctll::list<lookahead_negative<Content...>, Tail...>, Output output) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), output);
}

template <size_t Id, typename... Content, typename... Tail, typename... Output> constexpr auto find_captures(ctll::list<capture<Id,Content...>, Tail...>, ctll::list<Output...>) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), ctll::list<Output..., captured_content<Id>>());
}

template <size_t Id, typename Name, typename... Content, typename... Tail, typename... Output> constexpr auto find_captures(ctll::list<capture_with_name<Id,Name,Content...>, Tail...>, ctll::list<Output...>) noexcept {
	return find_captures(ctll::list<Content..., Tail...>(), ctll::list<Output..., captured_content<Id, Name>>());
}

}

#endif

namespace ctre {

// calling with pattern prepare stack and triplet of iterators
template <typename Iterator, typename EndIterator, typename Pattern> 
constexpr inline auto match_re(const Iterator begin, const EndIterator end, Pattern pattern) noexcept {
	using return_type = decltype(regex_results(std::declval<Iterator>(), find_captures(pattern)));
	return evaluate(begin, begin, end, return_type{}, ctll::list<start_mark, Pattern, assert_end, end_mark, accept>());
}

template <typename Iterator, typename EndIterator, typename Pattern> 
constexpr inline auto search_re(const Iterator begin, const EndIterator end, Pattern pattern) noexcept {
	using return_type = decltype(regex_results(std::declval<Iterator>(), find_captures(pattern)));
	
	auto it = begin;
	for (; end != it; ++it) {
		if (auto out = evaluate(begin, it, end, return_type{}, ctll::list<start_mark, Pattern, end_mark, accept>())) {
			return out;
		}
	}
	
	// in case the RE is empty
	return evaluate(begin, it, end, return_type{}, ctll::list<start_mark, Pattern, end_mark, accept>());
}

// sink for making the errors shorter
template <typename R, typename Iterator, typename EndIterator> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator, Iterator, const EndIterator, R, ...) noexcept {
	return R{};
}

// if we found "accept" object on stack => ACCEPT
template <typename R, typename Iterator, typename EndIterator> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator, Iterator, const EndIterator, R captures, ctll::list<accept>) noexcept {
	return captures.matched();
}

// if we found "reject" object on stack => REJECT
template <typename R, typename... Rest, typename Iterator, typename EndIterator> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator, Iterator, const EndIterator, R, ctll::list<reject, Rest...>) noexcept {
	return R{}; // just return not matched return type
}

// mark start of outer capture
template <typename R, typename Iterator, typename EndIterator, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<start_mark, Tail...>) noexcept {
	return evaluate(begin, current, end, captures.set_start_mark(current), ctll::list<Tail...>());
}

// mark end of outer capture
template <typename R, typename Iterator, typename EndIterator, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<end_mark, Tail...>) noexcept {
	return evaluate(begin, current, end, captures.set_end_mark(current), ctll::list<Tail...>());
}

// mark end of cycle
template <typename R, typename Iterator, typename EndIterator, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator, Iterator current, const EndIterator, R captures, ctll::list<end_cycle_mark>) noexcept {
	return captures.set_end_mark(current).matched();
}

// matching everything which behave as a one character matcher

template <typename R, typename Iterator, typename EndIterator, typename CharacterLike, typename... Tail, typename = std::enable_if_t<(MatchesCharacter<CharacterLike>::template value<decltype(*std::declval<Iterator>())>)>> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<CharacterLike, Tail...>) noexcept {
	if (end == current) return not_matched;
	if (!CharacterLike::match_char(*current)) return not_matched;
	return evaluate(begin, current+1, end, captures, ctll::list<Tail...>());
}

// matching strings in patterns

template <typename Iterator> struct string_match_result {
	Iterator current;
	bool match;
};

template <auto Head, auto... String, typename Iterator, typename EndIterator> constexpr CTRE_FORCE_INLINE string_match_result<Iterator> evaluate_match_string(Iterator current, const EndIterator end) noexcept {
	if ((end != current) && (Head == *current)) {
		if constexpr (sizeof...(String) > 0) {
			return evaluate_match_string<String...>(++current, end);
		} else {
			return {++current, true};
		}
	} else {
		return {++current, false}; // not needed but will optimize
	}
}

template <typename R, typename Iterator, typename EndIterator, auto... String, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<string<String...>, Tail...>) noexcept {
	if constexpr (sizeof...(String) == 0) {
		return evaluate(begin, current, end, captures, ctll::list<Tail...>());
	} else if (auto tmp = evaluate_match_string<String...>(current, end); tmp.match) {
		return evaluate(begin, tmp.current, end, captures, ctll::list<Tail...>());
	} else {
		return not_matched;
	}
}

// matching select in patterns
template <typename R, typename Iterator, typename EndIterator, typename HeadOptions, typename... TailOptions, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<select<HeadOptions, TailOptions...>, Tail...>) noexcept {
	if (auto r = evaluate(begin, current, end, captures, ctll::list<HeadOptions, Tail...>())) {
		return r;
	} else {
		return evaluate(begin, current, end, captures, ctll::list<select<TailOptions...>, Tail...>());
	}
}

template <typename R, typename Iterator, typename EndIterator, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator, Iterator, const EndIterator, R, ctll::list<select<>, Tail...>) noexcept {
	// no previous option was matched => REJECT
	return not_matched;
}

// matching optional in patterns
template <typename R, typename Iterator, typename EndIterator, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<optional<Content...>, Tail...>) noexcept {
	if (auto r1 = evaluate(begin, current, end, captures, ctll::list<sequence<Content...>, Tail...>())) {
		return r1;
	} else if (auto r2 = evaluate(begin, current, end, captures, ctll::list<Tail...>())) {
		return r2;
	} else {
		return not_matched;
	}
}

// lazy optional
template <typename R, typename Iterator, typename EndIterator, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<lazy_optional<Content...>, Tail...>) noexcept {
	if (auto r1 = evaluate(begin, current, end, captures, ctll::list<Tail...>())) {
		return r1;
	} else if (auto r2 = evaluate(begin, current, end, captures, ctll::list<sequence<Content...>, Tail...>())) {
		return r2;
	} else {
		return not_matched;
	}
}

// matching sequence in patterns
template <typename R, typename Iterator, typename EndIterator, typename HeadContent, typename... TailContent, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<sequence<HeadContent, TailContent...>, Tail...>) noexcept {
	if constexpr (sizeof...(TailContent) > 0) {
		return evaluate(begin, current, end, captures, ctll::list<HeadContent, sequence<TailContent...>, Tail...>());
	} else {
		return evaluate(begin, current, end, captures, ctll::list<HeadContent, Tail...>());
	}
}

// matching empty in patterns
template <typename R, typename Iterator, typename EndIterator, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<empty, Tail...>) noexcept {
	return evaluate(begin, current, end, captures, ctll::list<Tail...>());
}

// matching asserts
template <typename R, typename Iterator, typename EndIterator, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<assert_begin, Tail...>) noexcept {
	if (begin != current) {
		return not_matched;
	}
	return evaluate(begin, current, end, captures, ctll::list<Tail...>());
}

template <typename R, typename Iterator, typename EndIterator, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<assert_end, Tail...>) noexcept {
	if (end != current) {
		return not_matched;
	}
	return evaluate(begin, current, end, captures, ctll::list<Tail...>());
}

// lazy repeat
template <typename R, typename Iterator, typename EndIterator, size_t A, size_t B, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<lazy_repeat<A,B,Content...>, Tail...>) noexcept {
	// A..B
	size_t i{0};
	for (; i < A && (A != 0); ++i) {
		if (auto outer_result = evaluate(begin, current, end, captures, ctll::list<sequence<Content...>, end_cycle_mark>())) {
			captures = outer_result.unmatch();
			current = outer_result.get_end_position();
		} else {
			return not_matched;
		}
	}
	
	if (auto outer_result = evaluate(begin, current, end, captures, ctll::list<Tail...>())) {
		return outer_result;
	} else {
		for (; (i < B) || (B == 0); ++i) {
			if (auto inner_result = evaluate(begin, current, end, captures, ctll::list<sequence<Content...>, end_cycle_mark>())) {
				if (auto outer_result = evaluate(begin, inner_result.get_end_position(), end, inner_result.unmatch(), ctll::list<Tail...>())) {
					return outer_result;
				} else {
					captures = inner_result.unmatch();
					current = inner_result.get_end_position();
					continue;
				}
			} else {
				return not_matched;
			}
		}
		return evaluate(begin, current, end, captures, ctll::list<Tail...>());
	}
}

// possessive repeat
template <typename R, typename Iterator, typename EndIterator, size_t A, size_t B, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<possessive_repeat<A,B,Content...>, Tail...>) noexcept {
	// A..B
	size_t i{0};
	for (; i < A && (A != 0); ++i) {
		if (auto inner_result = evaluate(begin, current, end, captures, ctll::list<sequence<Content...>, end_cycle_mark>())) {
			captures = inner_result.unmatch();
			current = inner_result.get_end_position();
		} else {
			return not_matched;
		}
	}
	
	for (; (i < B) || (B == 0); ++i) {
		// try as many of inner as possible and then try outer once
		if (auto inner_result = evaluate(begin, current, end, captures, ctll::list<sequence<Content...>, end_cycle_mark>())) {
			current = inner_result.get_end_position();
		} else {
			return evaluate(begin, current, end, captures, ctll::list<Tail...>());
		}
	}
	
	return evaluate(begin, current, end, captures, ctll::list<Tail...>());
}

// (gready) repeat
template <typename R, typename Iterator, typename EndIterator, size_t A, size_t B, typename... Content, typename... Tail> 
constexpr inline R evaluate_recursive(size_t i, const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<repeat<A,B,Content...>, Tail...> stack) {
	if ((i < B) || (B == 0)) {
		 
		// a*ab
		// aab
		
		if (auto inner_result = evaluate(begin, current, end, captures, ctll::list<sequence<Content...>, end_cycle_mark>())) {
			// TODO MSVC issue:
			// if I uncomment this return it will not fail in constexpr (but the matching result will not be correct)
			//  return inner_result
			// I tried to add all constructors to R but without any success 
			if (auto rec_result = evaluate_recursive(i+1, begin, inner_result.get_end_position(), end, inner_result.unmatch(), stack)) {
				return rec_result;
			}
		}
	} 
	return evaluate(begin, current, end, captures, ctll::list<Tail...>());
}	

template <typename R, typename Iterator, typename EndIterator, size_t A, size_t B, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<repeat<A,B,Content...>, Tail...> stack) {
	// A..B
	size_t i{0};
	for (; i < A && (A != 0); ++i) {
		if (auto inner_result = evaluate(begin, current, end, captures, ctll::list<sequence<Content...>, end_cycle_mark>())) {
			captures = inner_result.unmatch();
			current = inner_result.get_end_position();
		} else {
			return not_matched;
		}
	}
	
	return evaluate_recursive(i, begin, current, end, captures, stack);
}

// repeat lazy_star
template <typename R, typename Iterator, typename EndIterator, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<lazy_star<Content...>, Tail...>) noexcept {
	return evaluate(begin, current, end, captures, ctll::list<lazy_repeat<0,0,Content...>, Tail...>());
}

// repeat (lazy_plus)
template <typename R, typename Iterator, typename EndIterator, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<lazy_plus<Content...>, Tail...>) noexcept {
	return evaluate(begin, current, end, captures, ctll::list<lazy_repeat<1,0,Content...>, Tail...>());
}

// repeat (possessive_star)
template <typename R, typename Iterator, typename EndIterator, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<possessive_star<Content...>, Tail...>) noexcept {
	return evaluate(begin, current, end, captures, ctll::list<possessive_repeat<0,0,Content...>, Tail...>());
}

// repeat (possessive_plus)
template <typename R, typename Iterator, typename EndIterator, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<possessive_plus<Content...>, Tail...>) noexcept {
	return evaluate(begin, current, end, captures, ctll::list<possessive_repeat<1,0,Content...>, Tail...>());
}

// repeat (greedy) star
template <typename R, typename Iterator, typename EndIterator, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<star<Content...>, Tail...>) noexcept {
	return evaluate(begin, current, end, captures, ctll::list<repeat<0,0,Content...>, Tail...>());
}

// repeat (greedy) plus
template <typename R, typename Iterator, typename EndIterator, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<plus<Content...>, Tail...>) noexcept {
	return evaluate(begin, current, end, captures, ctll::list<repeat<1,0,Content...>, Tail...>());
}

// capture (numeric ID)
template <typename R, typename Iterator, typename EndIterator, size_t Id, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<capture<Id, Content...>, Tail...>) noexcept {
	return evaluate(begin, current, end, captures.template start_capture<Id>(current), ctll::list<sequence<Content...>, numeric_mark<Id>, Tail...>());
}

// capture end mark (numeric and string ID)
template <typename R, typename Iterator, typename EndIterator, size_t Id, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<numeric_mark<Id>, Tail...>) noexcept {
	return evaluate(begin, current, end, captures.template end_capture<Id>(current), ctll::list<Tail...>());
}

// capture (string ID)
template <typename R, typename Iterator, typename EndIterator, size_t Id, typename Name, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<capture_with_name<Id, Name, Content...>, Tail...>) noexcept {
	return evaluate(begin, current, end, captures.template start_capture<Id>(current), ctll::list<sequence<Content...>, numeric_mark<Id>, Tail...>());
}

// backreference support (match agains content of iterators)
template <typename Iterator, typename EndIterator> constexpr CTRE_FORCE_INLINE string_match_result<Iterator> match_against_range(Iterator current, const EndIterator end, Iterator range_current, const Iterator range_end) noexcept {
	while (current != end && range_current != range_end) {
		if (*current == *range_current) {
			current++;
			range_current++;
		} else {
			return {current, false};
		}
	}
	return {current, range_current == range_end};
}

// backreference with name
template <typename R, typename Id, typename Iterator, typename EndIterator, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<back_reference_with_name<Id>, Tail...>) noexcept {
	
	if (const auto ref = captures.template get<Id>()) {
		if (auto tmp = match_against_range(current, end, ref.begin(), ref.end()); tmp.match) {
			return evaluate(begin, tmp.current, end, captures, ctll::list<Tail...>());
		}
	}
	return not_matched;
}

// backreference
template <typename R, size_t Id, typename Iterator, typename EndIterator, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<back_reference<Id>, Tail...>) noexcept {
	
	if (const auto ref = captures.template get<Id>()) {
		if (auto tmp = match_against_range(current, end, ref.begin(), ref.end()); tmp.match) {
			return evaluate(begin, tmp.current, end, captures, ctll::list<Tail...>());
		}
	}
	return not_matched;
}

// end of lookahead
template <typename R, typename Iterator, typename EndIterator, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator, Iterator, const EndIterator, R captures, ctll::list<end_lookahead_mark>) noexcept {
	return captures.matched();
}

// lookahead positive
template <typename R, typename Iterator, typename EndIterator, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<lookahead_positive<Content...>, Tail...>) noexcept {
	
	if (auto lookahead_result = evaluate(begin, current, end, captures, ctll::list<sequence<Content...>, end_lookahead_mark>())) {
		captures = lookahead_result.unmatch();
		return evaluate(begin, current, end, captures, ctll::list<Tail...>());
	} else {
		return not_matched;
	}
}

// lookahead negative
template <typename R, typename Iterator, typename EndIterator, typename... Content, typename... Tail> 
constexpr CTRE_FORCE_INLINE R evaluate(const Iterator begin, Iterator current, const EndIterator end, R captures, ctll::list<lookahead_negative<Content...>, Tail...>) noexcept {
	
	if (auto lookahead_result = evaluate(begin, current, end, captures, ctll::list<sequence<Content...>, end_lookahead_mark>())) {
		return not_matched;
	} else {
		return evaluate(begin, current, end, captures, ctll::list<Tail...>());
	}
}

// property matching

}

#endif

#ifndef CTRE__WRAPPER__HPP
#define CTRE__WRAPPER__HPP

#ifndef CTRE__TRANSLATE_DFA__HPP
#define CTRE__TRANSLATE_DFA__HPP

#ifndef CTRE__CTFA_WRAPPER__HPP
#define CTRE__CTFA_WRAPPER__HPP

#ifndef CTFA__HPP
#define CTFA__HPP

#ifndef CTFA__BASIC__HPP
#define CTFA__BASIC__HPP

#ifndef CTFA__BASIC__FA__HPP
#define CTFA__BASIC__FA__HPP

#include <cstddef>
#ifndef CTFA__CONTAINER__SET__HPP
#define CTFA__CONTAINER__SET__HPP

#include <cstddef>
#include <iterator>
#ifndef CTFA__HELPER__CONDITIONAL__HPP
#define CTFA__HELPER__CONDITIONAL__HPP

namespace ctfa {

template <bool> struct conditional_helper;

template <> struct conditional_helper<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional_helper<false> {
	template <typename, typename T> using type = T;
};

}

#endif

namespace ctfa {

template <bool C, typename T, typename F> using conditional = typename conditional_helper<C>::template type<T,F>;

template <typename T, size_t Capacity> class set {
	// I'm using C array, because it's much quicker in compile-time
	size_t _size{0};
	
	struct storage {
		T _data[Capacity]{};
		constexpr const T * data() const {
			return _data;
		}
		constexpr T * data() {
			return _data;
		}
	};
	
	struct empty_storage {
		constexpr const T * data() const {
			return nullptr;
		}
		constexpr T * data() {
			return nullptr;
		}
	};
	
	
	using data_t = conditional<(Capacity > 0), storage, empty_storage>;
	
	data_t _data;
	
	template <typename, size_t> friend class set;
public:
	static constexpr size_t capacity = Capacity;
	using iterator = T *;
	constexpr set() { }
	
	constexpr set(const std::initializer_list<T> & list) {
		for (const auto & v: list) {
			insert(v);
		}
	}
	constexpr set(const set & rhs) = default;
	template <size_t S2> constexpr set(const set<T, S2> & rhs) {
		for (const auto & v: rhs) {
			push_back(v);
		}
	}
	constexpr const T * data() const {
		return _data.data();
	}
	constexpr T * data() {
		return _data.data();
	}
	constexpr auto begin() {
		return data();
	}
	constexpr auto end() {
		return data() + _size;
	}
	constexpr auto begin() const {
		return data();
	}
	constexpr auto end() const {
		return data() + _size;
	}
	constexpr size_t size() const {
		return _size;
	}
	constexpr const auto & first() const {
		return *_data;
	}
	constexpr const auto & last() const {
		return _data[_size - 1];
	}
	template <size_t C> constexpr bool operator==(const set<T,C> & rhs) const {
		if (_size != rhs._size) return false;
		for (size_t i = 0; i != _size; ++i) {
			if (!(data()[i] == rhs.data()[i])) return false;
		}
		return true;
	}
	template <size_t C> constexpr bool operator<(const set<T,C> & rhs) const {
		for (size_t i = 0; i != _size && i != rhs._size; ++i) {
			if (data()[i] == rhs.data()[i]) continue;
			else if (data()[i] < rhs.data()[i]) return true;
			else return false;
		}
		return _size < rhs._size;
	}
	constexpr auto & operator[](size_t idx) const {
		return data()[idx];
	} 
	constexpr auto & operator[](size_t idx) {
		return data()[idx];
	} 
	template <typename Arg> constexpr auto upper_bound(Arg && obj) {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (!(obj < *it)) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto upper_bound(Arg && obj) const {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (!(obj < *it)) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto lower_bound(Arg && obj) {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (*it < obj) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto lower_bound(Arg && obj) const {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (*it < obj) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto find(Arg && obj) {
		auto it = lower_bound(std::forward<Arg>(obj));
		if (it != end() && *it == obj) return it;
		else return end();
	}
	template <typename Arg> constexpr auto find(Arg && obj) const {
		auto it = lower_bound(std::forward<Arg>(obj));
		if (it != end() && *it == obj) return it;
		else return end();
	}
	template <typename Arg> constexpr auto find_linear(Arg && obj) {
		auto it = begin();
		while (it != end()) {
			if (*it == obj) return it;
			it++;
		}
		return it;
	}
	template <typename Arg> constexpr auto find_linear(Arg && obj) const {
		auto it = begin();
		while (it != end()) {
			if (*it == obj) return it;
			it++;
		}
		return it;
	}
	constexpr std::pair<iterator, bool> insert(T obj) {
		auto it = lower_bound(obj);
		if (it == end()) {
			[[maybe_unused]] auto check = data()[_size];
			*it = obj;
			_size++;
			return {it, true};
		} else if (*it == obj) {
			return {it, false};
		} else {
			[[maybe_unused]] auto check = data()[_size];
			auto out = it;
			while (it != end()) {
				// swap
				auto tmp = std::move(*it);
				*it = std::move(obj);
				obj = std::move(tmp);
				
				it++;
			}
			// swap
			auto tmp = std::move(*it);
			*it = std::move(obj);
			obj = std::move(tmp);
			
			_size++;
			return {out, true};
		}
	}
	constexpr void push_back(T obj) {
		auto it = end();
		*it = obj;
		_size++;
	}
	template <typename Arg> constexpr bool remove(Arg && obj) {
		auto it = lower_bound(std::forward<Arg>(obj));
		if (it != end() && *it == obj) {
			return remove(it);
		} else {
			return false;
		}
	}
	constexpr iterator remove(iterator erase_it) {
		iterator out = erase_it;
		if (erase_it == end()) { 
			return out;
		}
		
		while (erase_it != end()) {
			auto next = erase_it;
			next++;
			if (next != end()) {
				*erase_it = std::move(*next);
			}
			erase_it++;
		}
		_size--;
		return out;
	}
};

}

#endif

#ifndef CTFA__BASIC__TRANSITION__HPP
#define CTFA__BASIC__TRANSITION__HPP

#ifndef CTFA__BASIC__STATE__HPP
#define CTFA__BASIC__STATE__HPP

#ifndef CTFA__CONDITION__HPP
#define CTFA__CONDITION__HPP

#include <string_view>
#ifndef CTFA__UTILITY__HPP
#define CTFA__UTILITY__HPP

#ifdef _MSC_VER
#define CTFA_FORCE_INLINE __forceinline
#define CTFA_FLATTEN
#else
#define CTFA_FORCE_INLINE inline __attribute__((always_inline))
#define CTFA_FLATTEN __attribute__((flatten))
#endif

namespace ctfa {
	struct zero_terminated_string_end_iterator {
		constexpr inline zero_terminated_string_end_iterator() = default;
		constexpr CTFA_FORCE_INLINE bool operator==(const char * ptr) const noexcept {
			return *ptr == '\0';
		} 
		constexpr CTFA_FORCE_INLINE bool operator==(const wchar_t * ptr) const noexcept {
			return *ptr == 0;
		} 
		constexpr CTFA_FORCE_INLINE bool operator!=(const char * ptr) const noexcept {
			return *ptr != '\0';
		} 
		constexpr CTFA_FORCE_INLINE bool operator!=(const wchar_t * ptr) const noexcept {
			return *ptr != 0;
		} 
	};
}

#endif

namespace ctfa {

namespace impl {

struct range {
	char32_t low{};
	char32_t high{};
	CTFA_FORCE_INLINE constexpr bool match(char32_t v) const noexcept {
		return (low <= v) && (v <= high);
	}
	constexpr bool operator<(const range & rhs) const noexcept {
		if (low == rhs.low) {
			return high < rhs.high;
		}
		return low < rhs.low;
	}
	constexpr bool operator==(const range & rhs) const noexcept {
		return low == rhs.low && high == rhs.high;
	}
	constexpr bool operator!=(const range & rhs) const noexcept {
		return low != rhs.low || high != rhs.high;
	}
	template <typename CB> void debug(CB && cb) const {
		if (low == std::numeric_limits<char32_t>::min() && high == std::numeric_limits<char32_t>::max()) {
			cb("anything");
			return;
		}
	
		if (low == std::numeric_limits<char32_t>::min()) cb("MIN");
		else if (low >= 32 && low <= 126) cb('\'',static_cast<char>(low),'\'');
		else cb(low);
		
		if (low != high) {
			cb("..");
			if (high == std::numeric_limits<char32_t>::max()) cb("MAX");
			else if (high >= 32 && high <= 126) cb('\'',static_cast<char>(high),'\'');
			else cb(high);
		}
	}
};

}

struct condition {
	impl::range r;

	constexpr condition() noexcept { }
	
	constexpr condition(const impl::range & r) noexcept: r{r} { }
	
	CTFA_FORCE_INLINE constexpr bool match(char32_t value) const noexcept {
		return r.match(value);
	}
	constexpr bool operator<(const condition & rhs) const noexcept {
		return r < rhs.r;
	}
	constexpr bool operator==(const condition & rhs) const noexcept {
		return r == rhs.r;
	}
	constexpr bool operator!=(const condition & rhs) const noexcept {
		return r != rhs.r;
	}
	template <typename CB> constexpr void debug(CB && cb) const {
		r.debug(cb);
	}
};

namespace matcher {

template <char32_t C> static constexpr auto unit = condition(impl::range{C,C});
template <char32_t A, char32_t B> static constexpr auto range = condition(impl::range{A,B});
static constexpr auto anything = condition(impl::range{std::numeric_limits<char32_t>::min(), std::numeric_limits<char32_t>::max()});

}

}

#endif

namespace ctfa {

struct state {
	int id{-1};
	
	static constexpr int placeholder = -2;
	static constexpr int invalid = -1;
	static constexpr int start = 0;
	
	constexpr bool operator<(const state & rhs) const noexcept {
		return id < rhs.id;
	}
	constexpr bool operator<=(const state & rhs) const noexcept {
		return id <= rhs.id;
	}
	constexpr bool operator==(const state & rhs) const noexcept {
		return id == rhs.id;
	}
	constexpr bool operator!=(const state & rhs) const noexcept {
		return id != rhs.id;
	}
	constexpr state prefix_base(state base) const noexcept {
		return state{id+base.id};
	}
	constexpr state prefix(state base) const noexcept {
		return state{id+base.id};
	}
	constexpr state next() const noexcept {
		return state{id+1};
	}
	constexpr bool is_start() const noexcept {
		return id == start;
	}
};

static constexpr auto start_state = state{state::start};
static constexpr auto invalid_state = state{state::invalid};

}

#endif

namespace ctfa {

struct transition {
	state source;
	state target;
	condition cond;
	constexpr bool operator<(state current) const noexcept {
		return source < current;
	}
	constexpr bool operator==(state current) const noexcept {
		return source == current;
	}
	constexpr bool operator!=(state current) const noexcept {
		return !operator==(current);
	}
	constexpr bool operator<(const transition & rhs) const noexcept {
		if (source == rhs.source) {
			if (cond == rhs.cond) {
				return target < rhs.target;
			}
			return cond < rhs.cond;
		}
		return source < rhs.source;
	}
	constexpr bool operator==(const transition & rhs) const noexcept {
		return source == rhs.source && target == rhs.target && cond == rhs.cond;
	}
	constexpr bool operator!=(const transition & rhs) const noexcept {
		return !operator==(rhs);
	}
	constexpr bool match(char32_t current) const noexcept {
		return cond.match(current);
	}
	constexpr bool is_start() const noexcept {
		return source.is_start();
	}
	constexpr transition prefix(state base) const noexcept {
		return transition{
			source.prefix(base),
			target.prefix(base),
			cond
		};
	}
	constexpr transition prefix_base(state base) const noexcept {
		return transition{
			source.prefix_base(base),
			target.prefix_base(base),
			cond
		};
	}
};

}

#endif

namespace ctfa {

struct transition_count_pair {
	size_t from_start{0};
	size_t other{0};
};

template <size_t Transitions, size_t FinalStates> struct finite_automaton {
	ctfa::set<transition, Transitions> transitions{};
	ctfa::set<state, FinalStates> final_states{};
	
	constexpr finite_automaton() = default;
	constexpr finite_automaton(const ctfa::set<transition, Transitions> & t, const ctfa::set<state, FinalStates> & f): transitions{t}, final_states{f} { }
	
	constexpr bool is_final(state s) const noexcept {
		if (s == invalid_state) return false;
		return final_states.find(s) != final_states.end();
	}

	constexpr auto create_blank() const noexcept {
		return finite_automaton<Transitions, FinalStates>{};
	}
	
	constexpr state next_free_state() const noexcept {
		state highest = invalid_state;
		// I need to iterate because there can be unaccessible state (it's sorted source,target )
		for (const auto & t: transitions) {
			highest = std::max(t.source, highest);
			highest = std::max(t.target, highest);
		}
		for (state s: final_states) {
			highest = std::max(s, highest);
		}
		return highest.next();
	}
	constexpr void add(const transition & t) {
		transitions.insert(t);
	}
	constexpr void mark_final(state s) {
		final_states.insert(s);
	}
	template <size_t T, size_t F> constexpr bool operator==(const finite_automaton<T,F> & rhs) const noexcept {
		return final_states == rhs.final_states && transitions == rhs.transitions;
	}
};

template <const auto & Fa, typename TransitionCB, typename FinalCB> void debug(TransitionCB && tran, FinalCB && final) {
	for (const auto & t: Fa.transitions) {
		tran(t.source, t.target, t.cond, Fa.is_final(t.source));
	}
	for (const auto & f: Fa.final_states) {
		if (Fa.transitions.find(f) == Fa.transitions.end()) final(f);
	}
}

template <typename F> struct filtered_out {
	F fa;
	size_t transitions;
	size_t final_states;
};

template <typename F> filtered_out(const F &, size_t, size_t) -> filtered_out<F>;

}

#endif

namespace ctfa::block {

static constexpr auto empty = finite_automaton<0,1>{{}, {state{0}}};

static constexpr auto reject_all = finite_automaton<0,0>{{}, {}};

template <char32_t Value> static constexpr auto unit = finite_automaton<1,1>{{transition{state{0}, state{1}, ctfa::matcher::unit<Value>}}, {state{1}}};

template <char32_t A, char32_t B> static constexpr auto range = finite_automaton<1,1>{{transition{state{0}, state{1}, ctfa::matcher::range<A,B>}}, {state{1}}};

static constexpr auto anything = finite_automaton<1,1>{{transition{state{0}, state{1}, ctfa::matcher::anything}}, {state{1}}};

template <char32_t... Str> static constexpr auto string = []{
	char32_t buffer[] = {Str...};
	finite_automaton<sizeof...(Str),1> out;
	for (int i = 0; i != sizeof...(Str); ++i) {
		out.add(transition{state{i}, state{i+1}, condition{impl::range{buffer[i], buffer[i]}}});
	}
	out.mark_final(state{sizeof...(Str)});
	return out;
}();

template <char32_t... Values> static constexpr auto set = []{
	finite_automaton<sizeof...(Values),1> out;
	(out.add(transition{start_state, state{1}, condition{impl::range{Values, Values}}}), ...);
	out.mark_final(invalid_state);
	return out;
}();

}

#endif

#ifndef CTFA__TRANSFORMATION__HPP
#define CTFA__TRANSFORMATION__HPP

#ifndef CTFA__TRANSFORMATION__ALTERNATIVE__HPP
#define CTFA__TRANSFORMATION__ALTERNATIVE__HPP

#ifndef CTFA__BASIC__FA__HPP
#define CTFA__BASIC__FA__HPP

#include <cstddef>
#ifndef CTFA__CONTAINER__SET__HPP
#define CTFA__CONTAINER__SET__HPP

#include <cstddef>
#include <iterator>
#ifndef CTFA__HELPER__CONDITIONAL__HPP
#define CTFA__HELPER__CONDITIONAL__HPP

namespace ctfa {

template <bool> struct conditional_helper;

template <> struct conditional_helper<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional_helper<false> {
	template <typename, typename T> using type = T;
};

}

#endif

namespace ctfa {

template <bool C, typename T, typename F> using conditional = typename conditional_helper<C>::template type<T,F>;

template <typename T, size_t Capacity> class set {
	// I'm using C array, because it's much quicker in compile-time
	size_t _size{0};
	
	struct storage {
		T _data[Capacity]{};
		constexpr const T * data() const {
			return _data;
		}
		constexpr T * data() {
			return _data;
		}
	};
	
	struct empty_storage {
		constexpr const T * data() const {
			return nullptr;
		}
		constexpr T * data() {
			return nullptr;
		}
	};
	
	
	using data_t = conditional<(Capacity > 0), storage, empty_storage>;
	
	data_t _data;
	
	template <typename, size_t> friend class set;
public:
	static constexpr size_t capacity = Capacity;
	using iterator = T *;
	constexpr set() { }
	
	constexpr set(const std::initializer_list<T> & list) {
		for (const auto & v: list) {
			insert(v);
		}
	}
	constexpr set(const set & rhs) = default;
	template <size_t S2> constexpr set(const set<T, S2> & rhs) {
		for (const auto & v: rhs) {
			push_back(v);
		}
	}
	constexpr const T * data() const {
		return _data.data();
	}
	constexpr T * data() {
		return _data.data();
	}
	constexpr auto begin() {
		return data();
	}
	constexpr auto end() {
		return data() + _size;
	}
	constexpr auto begin() const {
		return data();
	}
	constexpr auto end() const {
		return data() + _size;
	}
	constexpr size_t size() const {
		return _size;
	}
	constexpr const auto & first() const {
		return *_data;
	}
	constexpr const auto & last() const {
		return _data[_size - 1];
	}
	template <size_t C> constexpr bool operator==(const set<T,C> & rhs) const {
		if (_size != rhs._size) return false;
		for (size_t i = 0; i != _size; ++i) {
			if (!(data()[i] == rhs.data()[i])) return false;
		}
		return true;
	}
	template <size_t C> constexpr bool operator<(const set<T,C> & rhs) const {
		for (size_t i = 0; i != _size && i != rhs._size; ++i) {
			if (data()[i] == rhs.data()[i]) continue;
			else if (data()[i] < rhs.data()[i]) return true;
			else return false;
		}
		return _size < rhs._size;
	}
	constexpr auto & operator[](size_t idx) const {
		return data()[idx];
	} 
	constexpr auto & operator[](size_t idx) {
		return data()[idx];
	} 
	template <typename Arg> constexpr auto upper_bound(Arg && obj) {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (!(obj < *it)) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto upper_bound(Arg && obj) const {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (!(obj < *it)) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto lower_bound(Arg && obj) {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (*it < obj) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto lower_bound(Arg && obj) const {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (*it < obj) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto find(Arg && obj) {
		auto it = lower_bound(std::forward<Arg>(obj));
		if (it != end() && *it == obj) return it;
		else return end();
	}
	template <typename Arg> constexpr auto find(Arg && obj) const {
		auto it = lower_bound(std::forward<Arg>(obj));
		if (it != end() && *it == obj) return it;
		else return end();
	}
	template <typename Arg> constexpr auto find_linear(Arg && obj) {
		auto it = begin();
		while (it != end()) {
			if (*it == obj) return it;
			it++;
		}
		return it;
	}
	template <typename Arg> constexpr auto find_linear(Arg && obj) const {
		auto it = begin();
		while (it != end()) {
			if (*it == obj) return it;
			it++;
		}
		return it;
	}
	constexpr std::pair<iterator, bool> insert(T obj) {
		auto it = lower_bound(obj);
		if (it == end()) {
			[[maybe_unused]] auto check = data()[_size];
			*it = obj;
			_size++;
			return {it, true};
		} else if (*it == obj) {
			return {it, false};
		} else {
			[[maybe_unused]] auto check = data()[_size];
			auto out = it;
			while (it != end()) {
				// swap
				auto tmp = std::move(*it);
				*it = std::move(obj);
				obj = std::move(tmp);
				
				it++;
			}
			// swap
			auto tmp = std::move(*it);
			*it = std::move(obj);
			obj = std::move(tmp);
			
			_size++;
			return {out, true};
		}
	}
	constexpr void push_back(T obj) {
		auto it = end();
		*it = obj;
		_size++;
	}
	template <typename Arg> constexpr bool remove(Arg && obj) {
		auto it = lower_bound(std::forward<Arg>(obj));
		if (it != end() && *it == obj) {
			return remove(it);
		} else {
			return false;
		}
	}
	constexpr iterator remove(iterator erase_it) {
		iterator out = erase_it;
		if (erase_it == end()) { 
			return out;
		}
		
		while (erase_it != end()) {
			auto next = erase_it;
			next++;
			if (next != end()) {
				*erase_it = std::move(*next);
			}
			erase_it++;
		}
		_size--;
		return out;
	}
};

}

#endif

#ifndef CTFA__BASIC__TRANSITION__HPP
#define CTFA__BASIC__TRANSITION__HPP

#ifndef CTFA__BASIC__STATE__HPP
#define CTFA__BASIC__STATE__HPP

#ifndef CTFA__CONDITION__HPP
#define CTFA__CONDITION__HPP

#include <string_view>
#ifndef CTFA__UTILITY__HPP
#define CTFA__UTILITY__HPP

#ifdef _MSC_VER
#define CTFA_FORCE_INLINE __forceinline
#define CTFA_FLATTEN
#else
#define CTFA_FORCE_INLINE inline __attribute__((always_inline))
#define CTFA_FLATTEN __attribute__((flatten))
#endif

namespace ctfa {
	struct zero_terminated_string_end_iterator {
		constexpr inline zero_terminated_string_end_iterator() = default;
		constexpr CTFA_FORCE_INLINE bool operator==(const char * ptr) const noexcept {
			return *ptr == '\0';
		} 
		constexpr CTFA_FORCE_INLINE bool operator==(const wchar_t * ptr) const noexcept {
			return *ptr == 0;
		} 
		constexpr CTFA_FORCE_INLINE bool operator!=(const char * ptr) const noexcept {
			return *ptr != '\0';
		} 
		constexpr CTFA_FORCE_INLINE bool operator!=(const wchar_t * ptr) const noexcept {
			return *ptr != 0;
		} 
	};
}

#endif

namespace ctfa {

namespace impl {

struct range {
	char32_t low{};
	char32_t high{};
	CTFA_FORCE_INLINE constexpr bool match(char32_t v) const noexcept {
		return (low <= v) && (v <= high);
	}
	constexpr bool operator<(const range & rhs) const noexcept {
		if (low == rhs.low) {
			return high < rhs.high;
		}
		return low < rhs.low;
	}
	constexpr bool operator==(const range & rhs) const noexcept {
		return low == rhs.low && high == rhs.high;
	}
	constexpr bool operator!=(const range & rhs) const noexcept {
		return low != rhs.low || high != rhs.high;
	}
	template <typename CB> void debug(CB && cb) const {
		if (low == std::numeric_limits<char32_t>::min() && high == std::numeric_limits<char32_t>::max()) {
			cb("anything");
			return;
		}
	
		if (low == std::numeric_limits<char32_t>::min()) cb("MIN");
		else if (low >= 32 && low <= 126) cb('\'',static_cast<char>(low),'\'');
		else cb(low);
		
		if (low != high) {
			cb("..");
			if (high == std::numeric_limits<char32_t>::max()) cb("MAX");
			else if (high >= 32 && high <= 126) cb('\'',static_cast<char>(high),'\'');
			else cb(high);
		}
	}
};

}

struct condition {
	impl::range r;

	constexpr condition() noexcept { }
	
	constexpr condition(const impl::range & r) noexcept: r{r} { }
	
	CTFA_FORCE_INLINE constexpr bool match(char32_t value) const noexcept {
		return r.match(value);
	}
	constexpr bool operator<(const condition & rhs) const noexcept {
		return r < rhs.r;
	}
	constexpr bool operator==(const condition & rhs) const noexcept {
		return r == rhs.r;
	}
	constexpr bool operator!=(const condition & rhs) const noexcept {
		return r != rhs.r;
	}
	template <typename CB> constexpr void debug(CB && cb) const {
		r.debug(cb);
	}
};

namespace matcher {

template <char32_t C> static constexpr auto unit = condition(impl::range{C,C});
template <char32_t A, char32_t B> static constexpr auto range = condition(impl::range{A,B});
static constexpr auto anything = condition(impl::range{std::numeric_limits<char32_t>::min(), std::numeric_limits<char32_t>::max()});

}

}

#endif

namespace ctfa {

struct state {
	int id{-1};
	
	static constexpr int placeholder = -2;
	static constexpr int invalid = -1;
	static constexpr int start = 0;
	
	constexpr bool operator<(const state & rhs) const noexcept {
		return id < rhs.id;
	}
	constexpr bool operator<=(const state & rhs) const noexcept {
		return id <= rhs.id;
	}
	constexpr bool operator==(const state & rhs) const noexcept {
		return id == rhs.id;
	}
	constexpr bool operator!=(const state & rhs) const noexcept {
		return id != rhs.id;
	}
	constexpr state prefix_base(state base) const noexcept {
		return state{id+base.id};
	}
	constexpr state prefix(state base) const noexcept {
		return state{id+base.id};
	}
	constexpr state next() const noexcept {
		return state{id+1};
	}
	constexpr bool is_start() const noexcept {
		return id == start;
	}
};

static constexpr auto start_state = state{state::start};
static constexpr auto invalid_state = state{state::invalid};

}

#endif

namespace ctfa {

struct transition {
	state source;
	state target;
	condition cond;
	constexpr bool operator<(state current) const noexcept {
		return source < current;
	}
	constexpr bool operator==(state current) const noexcept {
		return source == current;
	}
	constexpr bool operator!=(state current) const noexcept {
		return !operator==(current);
	}
	constexpr bool operator<(const transition & rhs) const noexcept {
		if (source == rhs.source) {
			if (cond == rhs.cond) {
				return target < rhs.target;
			}
			return cond < rhs.cond;
		}
		return source < rhs.source;
	}
	constexpr bool operator==(const transition & rhs) const noexcept {
		return source == rhs.source && target == rhs.target && cond == rhs.cond;
	}
	constexpr bool operator!=(const transition & rhs) const noexcept {
		return !operator==(rhs);
	}
	constexpr bool match(char32_t current) const noexcept {
		return cond.match(current);
	}
	constexpr bool is_start() const noexcept {
		return source.is_start();
	}
	constexpr transition prefix(state base) const noexcept {
		return transition{
			source.prefix(base),
			target.prefix(base),
			cond
		};
	}
	constexpr transition prefix_base(state base) const noexcept {
		return transition{
			source.prefix_base(base),
			target.prefix_base(base),
			cond
		};
	}
};

}

#endif

namespace ctfa {

struct transition_count_pair {
	size_t from_start{0};
	size_t other{0};
};

template <size_t Transitions, size_t FinalStates> struct finite_automaton {
	ctfa::set<transition, Transitions> transitions{};
	ctfa::set<state, FinalStates> final_states{};
	
	constexpr finite_automaton() = default;
	constexpr finite_automaton(const ctfa::set<transition, Transitions> & t, const ctfa::set<state, FinalStates> & f): transitions{t}, final_states{f} { }
	
	constexpr bool is_final(state s) const noexcept {
		if (s == invalid_state) return false;
		return final_states.find(s) != final_states.end();
	}

	constexpr auto create_blank() const noexcept {
		return finite_automaton<Transitions, FinalStates>{};
	}
	
	constexpr state next_free_state() const noexcept {
		state highest = invalid_state;
		// I need to iterate because there can be unaccessible state (it's sorted source,target )
		for (const auto & t: transitions) {
			highest = std::max(t.source, highest);
			highest = std::max(t.target, highest);
		}
		for (state s: final_states) {
			highest = std::max(s, highest);
		}
		return highest.next();
	}
	constexpr void add(const transition & t) {
		transitions.insert(t);
	}
	constexpr void mark_final(state s) {
		final_states.insert(s);
	}
	template <size_t T, size_t F> constexpr bool operator==(const finite_automaton<T,F> & rhs) const noexcept {
		return final_states == rhs.final_states && transitions == rhs.transitions;
	}
};

template <const auto & Fa, typename TransitionCB, typename FinalCB> void debug(TransitionCB && tran, FinalCB && final) {
	for (const auto & t: Fa.transitions) {
		tran(t.source, t.target, t.cond, Fa.is_final(t.source));
	}
	for (const auto & f: Fa.final_states) {
		if (Fa.transitions.find(f) == Fa.transitions.end()) final(f);
	}
}

template <typename F> struct filtered_out {
	F fa;
	size_t transitions;
	size_t final_states;
};

template <typename F> filtered_out(const F &, size_t, size_t) -> filtered_out<F>;

}

#endif

#ifndef CTFA__TRANSFORMATION__EPSILON__HPP
#define CTFA__TRANSFORMATION__EPSILON__HPP

namespace ctfa {

template <typename Fa, typename TransitionCB, typename FinalState> constexpr std::pair<size_t, bool> epsilon_for(const Fa & fa, state source, TransitionCB && transition_cb, FinalState && final_cb) {
	size_t transition_count = 0;
	bool is_final = false;
	auto it = (source == start_state) ? fa.transitions.begin() : fa.transitions.find(source);
	while (it != fa.transitions.end() && *it == source) {
		transition_cb(*it++);
		transition_count++;
	}
	auto fit = (source == start_state) ? fa.final_states.begin() : fa.final_states.find(source);
	if (fit != fa.final_states.end() && *fit == source) {
		final_cb(source);
		is_final = true;
	}
	return std::pair<size_t, bool>{transition_count, is_final};
}

template <typename Fa, typename TransitionCB> constexpr std::pair<size_t, bool> epsilon_for(const Fa & fa, state source, TransitionCB && transition_cb) {
	return epsilon_for(fa, source, std::forward<TransitionCB>(transition_cb), [](auto && ...){});
}

template <typename Fa> constexpr std::pair<size_t, bool> epsilon_join_count(const Fa & fa, state source) {
	return epsilon_for(fa, source, [](auto && ...){}, [](auto && ...){});
}

}

#endif

namespace ctfa {

template <const auto & Lhs, const auto & Rhs> struct alternative_two {
	static constexpr auto build() {
		constexpr std::pair lhs_info = epsilon_join_count(Lhs, start_state);
		constexpr std::pair rhs_info = epsilon_join_count(Rhs, start_state);
		constexpr size_t transitions = Lhs.transitions.size() + Rhs.transitions.size() + Lhs.final_states.size() * lhs_info.first + rhs_info.first;
		constexpr size_t final_states = Lhs.final_states.size() + Rhs.final_states.size() + std::max(lhs_info.second, rhs_info.second);
		
		finite_automaton<transitions, final_states> output;
		
		constexpr state lhs_base = start_state.next();
		constexpr state rhs_base = Lhs.next_free_state().next();
		
		// I can do this two push_backs because I know it's already sorted
		for (const auto & t: Lhs.transitions) {
			output.transitions.push_back(t.prefix(lhs_base)); // quicker than .add
		}
		
		for (const auto & t: Rhs.transitions) {
			output.transitions.push_back(t.prefix(rhs_base)); // quicker than .add
		}
		
		epsilon_for(Lhs, start_state, [&](transition t) {
			t.source = start_state;
			t.target = t.target.prefix_base(lhs_base);
			output.add(t);
		}, [&](state) {
			output.mark_final(start_state);
		});
		
		epsilon_for(Rhs, start_state, [&](transition t) {
			t.source = start_state;
			t.target = t.target.prefix_base(rhs_base);
			output.add(t);
		}, [&](state) {
			output.mark_final(start_state);
		});
		
		
		for (state s: Lhs.final_states) {
			output.mark_final(s.prefix_base(lhs_base));
		}
		
		for (state s: Rhs.final_states) {
			output.mark_final(s.prefix_base(rhs_base));
		}
		
		return output;
	}
	
	static constexpr auto result = build();
};

}

#endif

#ifndef CTFA__TRANSFORMATION__CONCAT__HPP
#define CTFA__TRANSFORMATION__CONCAT__HPP

namespace ctfa {

template <const auto & Lhs, const auto & Rhs> struct concat_two {
	static constexpr auto build() {
		constexpr std::pair info = epsilon_join_count(Rhs, start_state);
		constexpr size_t transitions = Lhs.transitions.size() + Rhs.transitions.size() + Lhs.final_states.size() * info.first;
		constexpr size_t final_states = Rhs.final_states.size() + info.second + Lhs.final_states.size();
		
		finite_automaton<transitions, final_states> output;
		
		// copy Lhs transitions
		for (const auto & t: Lhs.transitions) {
			output.transitions.push_back(t); // quicker
		}
		
		// prefix for all Rhs states in output
		constexpr state base = Lhs.next_free_state();
		
		static_assert(base != invalid_state);
		static_assert(base != start_state);
		
		for (state s: Lhs.final_states) {
			epsilon_for(Rhs, start_state, [&](transition t) {
				t.source = s;
				t.target = t.target.prefix(base);
				output.add(t);
			}, [&](state) {
				output.mark_final(s);
			});
		}

		// copy Rhs transitions + with base prefix
		for (const auto & t: Rhs.transitions) {
			output.add(t.prefix(base));
		}
		
		for (state s: Rhs.final_states) {
			output.mark_final(s.prefix(base));
		}
		
		return output;
	}
	
	static constexpr auto result = build();
};

}

#endif

#ifndef CTFA__TRANSFORMATION__OPTIONAL__HPP
#define CTFA__TRANSFORMATION__OPTIONAL__HPP

namespace ctfa {

template <const auto & Fa> struct optional_one {
	static constexpr auto build() {
		constexpr std::pair info = epsilon_join_count(Fa, start_state);
		constexpr size_t transitions = Fa.transitions.size() + info.first;
		constexpr size_t final_states = Fa.final_states.size() + 1;
		
		finite_automaton<transitions, final_states> output;
		
		constexpr state base = start_state.next();
		
		for (const auto & t: Fa.transitions) {
			output.transitions.push_back(t.prefix(base)); // quicker
		}
		
		epsilon_for(Fa, start_state, [&](transition t) {
			t.source = start_state;
			t.target = t.target.prefix(base);
			output.add(t);
		});
		
		output.mark_final(start_state);
		
		for (state s: Fa.final_states) {
			output.mark_final(s.prefix(base));
		}
		
		return output;
	}
	
	static constexpr auto result = build();
};

}

#endif

#ifndef CTFA__TRANSFORMATION__PLUS__HPP
#define CTFA__TRANSFORMATION__PLUS__HPP

namespace ctfa {

template <const auto & Fa> struct plus_one {
	static constexpr auto build() {
		constexpr std::pair info = epsilon_join_count(Fa, start_state);
		constexpr size_t transitions = Fa.transitions.size() + info.first * Fa.final_states.size() + info.first;
		constexpr size_t final_states = Fa.final_states.size() + info.second;
		
		finite_automaton<transitions, final_states> output;
		
		constexpr state base = start_state.next();
		
		// A + prefix => (B + prefix) (1 -> 2)
		for (const auto & t: Fa.transitions) {
			output.transitions.push_back(t.prefix(base));
		}
		
		// new_start => (old_start -> X) (0 -> 2)
		epsilon_for(Fa, start_state, [&](transition t) {
			t.source = start_state;
			t.target = t.target.prefix(base);
			output.add(t);
		}, [&](state f){
			output.mark_final(f);
		});
		
		// finals => (old_start -> X) (2 -> 2)
		for (state s: Fa.final_states) {
			epsilon_for(Fa, start_state, [&](transition t) {
				t.source = s;
				output.add(t.prefix(base));
			});
			output.mark_final(s.prefix(base));
		}
		
		return output;
	}
	
	static constexpr auto result = build();
};

}

#endif

#ifndef CTFA__TRANSFORMATION__STAR__HPP
#define CTFA__TRANSFORMATION__STAR__HPP

namespace ctfa {

template <const auto & Fa> struct star_one {
	static constexpr auto build() {
		constexpr std::pair info = epsilon_join_count(Fa, start_state);
		constexpr size_t transitions = Fa.transitions.size() + info.first * Fa.final_states.size() + info.first;
		constexpr size_t final_states = Fa.final_states.size() + info.second + 1;
		
		finite_automaton<transitions, final_states> output;
		
		constexpr state base = start_state.next();
		
		// A + prefix => (B + prefix) (1 -> 2)
		for (const auto & t: Fa.transitions) {
			output.transitions.push_back(t.prefix(base));
		}
		
		// new_start => (old_start -> X) (0 -> 2)
		epsilon_for(Fa, start_state, [&](transition t) {
			t.source = start_state;
			t.target = t.target.prefix(base);
			output.add(t);
		}, [&](state f){
			output.mark_final(f);
		});
		
		// finals => (old_start -> X) (2 -> 2)
		for (state s: Fa.final_states) {
			epsilon_for(Fa, start_state, [&](transition t) {
				t.source = s;
				output.add(t.prefix(base));
			});
			output.mark_final(s.prefix(base));
		}
		
		output.mark_final(start_state);
		
		return output;
	}
	
	static constexpr auto result = build();
};

}

#endif

#ifndef CTFA__TRANSFORMATION__SHRINK__HPP
#define CTFA__TRANSFORMATION__SHRINK__HPP

namespace ctfa {

template <const auto & Fa> struct shrink_one {
	static constexpr auto build() {
		constexpr size_t transitions = Fa.transitions.size();
		constexpr size_t final_states = Fa.final_states.size();
		
		ctfa::finite_automaton<transitions, final_states> out;
		
		for (const auto & t: Fa.transitions) {
			out.transitions.push_back(t); // I'm sure it's sorted
		}
		
		for (state f: Fa.final_states) {
			out.final_states.push_back(f); // I'm sure it's sorted
		}
		
		return out;
	}
	
	static constexpr auto result = build();
};

}

#endif

#ifndef CTFA__TRANSFORMATION__REMOVE_UNNEEDED__HPP
#define CTFA__TRANSFORMATION__REMOVE_UNNEEDED__HPP

#ifndef CTFA__HELPER__INFO__HPP
#define CTFA__HELPER__INFO__HPP

#ifndef CTFA__CONTAINER__SET__HPP
#define CTFA__CONTAINER__SET__HPP

#include <cstddef>
#include <iterator>
#ifndef CTFA__HELPER__CONDITIONAL__HPP
#define CTFA__HELPER__CONDITIONAL__HPP

namespace ctfa {

template <bool> struct conditional_helper;

template <> struct conditional_helper<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional_helper<false> {
	template <typename, typename T> using type = T;
};

}

#endif

namespace ctfa {

template <bool C, typename T, typename F> using conditional = typename conditional_helper<C>::template type<T,F>;

template <typename T, size_t Capacity> class set {
	// I'm using C array, because it's much quicker in compile-time
	size_t _size{0};
	
	struct storage {
		T _data[Capacity]{};
		constexpr const T * data() const {
			return _data;
		}
		constexpr T * data() {
			return _data;
		}
	};
	
	struct empty_storage {
		constexpr const T * data() const {
			return nullptr;
		}
		constexpr T * data() {
			return nullptr;
		}
	};
	
	
	using data_t = conditional<(Capacity > 0), storage, empty_storage>;
	
	data_t _data;
	
	template <typename, size_t> friend class set;
public:
	static constexpr size_t capacity = Capacity;
	using iterator = T *;
	constexpr set() { }
	
	constexpr set(const std::initializer_list<T> & list) {
		for (const auto & v: list) {
			insert(v);
		}
	}
	constexpr set(const set & rhs) = default;
	template <size_t S2> constexpr set(const set<T, S2> & rhs) {
		for (const auto & v: rhs) {
			push_back(v);
		}
	}
	constexpr const T * data() const {
		return _data.data();
	}
	constexpr T * data() {
		return _data.data();
	}
	constexpr auto begin() {
		return data();
	}
	constexpr auto end() {
		return data() + _size;
	}
	constexpr auto begin() const {
		return data();
	}
	constexpr auto end() const {
		return data() + _size;
	}
	constexpr size_t size() const {
		return _size;
	}
	constexpr const auto & first() const {
		return *_data;
	}
	constexpr const auto & last() const {
		return _data[_size - 1];
	}
	template <size_t C> constexpr bool operator==(const set<T,C> & rhs) const {
		if (_size != rhs._size) return false;
		for (size_t i = 0; i != _size; ++i) {
			if (!(data()[i] == rhs.data()[i])) return false;
		}
		return true;
	}
	template <size_t C> constexpr bool operator<(const set<T,C> & rhs) const {
		for (size_t i = 0; i != _size && i != rhs._size; ++i) {
			if (data()[i] == rhs.data()[i]) continue;
			else if (data()[i] < rhs.data()[i]) return true;
			else return false;
		}
		return _size < rhs._size;
	}
	constexpr auto & operator[](size_t idx) const {
		return data()[idx];
	} 
	constexpr auto & operator[](size_t idx) {
		return data()[idx];
	} 
	template <typename Arg> constexpr auto upper_bound(Arg && obj) {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (!(obj < *it)) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto upper_bound(Arg && obj) const {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (!(obj < *it)) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto lower_bound(Arg && obj) {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (*it < obj) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto lower_bound(Arg && obj) const {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (*it < obj) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto find(Arg && obj) {
		auto it = lower_bound(std::forward<Arg>(obj));
		if (it != end() && *it == obj) return it;
		else return end();
	}
	template <typename Arg> constexpr auto find(Arg && obj) const {
		auto it = lower_bound(std::forward<Arg>(obj));
		if (it != end() && *it == obj) return it;
		else return end();
	}
	template <typename Arg> constexpr auto find_linear(Arg && obj) {
		auto it = begin();
		while (it != end()) {
			if (*it == obj) return it;
			it++;
		}
		return it;
	}
	template <typename Arg> constexpr auto find_linear(Arg && obj) const {
		auto it = begin();
		while (it != end()) {
			if (*it == obj) return it;
			it++;
		}
		return it;
	}
	constexpr std::pair<iterator, bool> insert(T obj) {
		auto it = lower_bound(obj);
		if (it == end()) {
			[[maybe_unused]] auto check = data()[_size];
			*it = obj;
			_size++;
			return {it, true};
		} else if (*it == obj) {
			return {it, false};
		} else {
			[[maybe_unused]] auto check = data()[_size];
			auto out = it;
			while (it != end()) {
				// swap
				auto tmp = std::move(*it);
				*it = std::move(obj);
				obj = std::move(tmp);
				
				it++;
			}
			// swap
			auto tmp = std::move(*it);
			*it = std::move(obj);
			obj = std::move(tmp);
			
			_size++;
			return {out, true};
		}
	}
	constexpr void push_back(T obj) {
		auto it = end();
		*it = obj;
		_size++;
	}
	template <typename Arg> constexpr bool remove(Arg && obj) {
		auto it = lower_bound(std::forward<Arg>(obj));
		if (it != end() && *it == obj) {
			return remove(it);
		} else {
			return false;
		}
	}
	constexpr iterator remove(iterator erase_it) {
		iterator out = erase_it;
		if (erase_it == end()) { 
			return out;
		}
		
		while (erase_it != end()) {
			auto next = erase_it;
			next++;
			if (next != end()) {
				*erase_it = std::move(*next);
			}
			erase_it++;
		}
		_size--;
		return out;
	}
};

}

#endif

#ifndef CTFA__BASIC__FA__HPP
#define CTFA__BASIC__FA__HPP

#include <cstddef>
#ifndef CTFA__CONTAINER__SET__HPP
#define CTFA__CONTAINER__SET__HPP

#include <cstddef>
#include <iterator>
#ifndef CTFA__HELPER__CONDITIONAL__HPP
#define CTFA__HELPER__CONDITIONAL__HPP

namespace ctfa {

template <bool> struct conditional_helper;

template <> struct conditional_helper<true> {
	template <typename T, typename> using type = T;
};

template <> struct conditional_helper<false> {
	template <typename, typename T> using type = T;
};

}

#endif

namespace ctfa {

template <bool C, typename T, typename F> using conditional = typename conditional_helper<C>::template type<T,F>;

template <typename T, size_t Capacity> class set {
	// I'm using C array, because it's much quicker in compile-time
	size_t _size{0};
	
	struct storage {
		T _data[Capacity]{};
		constexpr const T * data() const {
			return _data;
		}
		constexpr T * data() {
			return _data;
		}
	};
	
	struct empty_storage {
		constexpr const T * data() const {
			return nullptr;
		}
		constexpr T * data() {
			return nullptr;
		}
	};
	
	
	using data_t = conditional<(Capacity > 0), storage, empty_storage>;
	
	data_t _data;
	
	template <typename, size_t> friend class set;
public:
	static constexpr size_t capacity = Capacity;
	using iterator = T *;
	constexpr set() { }
	
	constexpr set(const std::initializer_list<T> & list) {
		for (const auto & v: list) {
			insert(v);
		}
	}
	constexpr set(const set & rhs) = default;
	template <size_t S2> constexpr set(const set<T, S2> & rhs) {
		for (const auto & v: rhs) {
			push_back(v);
		}
	}
	constexpr const T * data() const {
		return _data.data();
	}
	constexpr T * data() {
		return _data.data();
	}
	constexpr auto begin() {
		return data();
	}
	constexpr auto end() {
		return data() + _size;
	}
	constexpr auto begin() const {
		return data();
	}
	constexpr auto end() const {
		return data() + _size;
	}
	constexpr size_t size() const {
		return _size;
	}
	constexpr const auto & first() const {
		return *_data;
	}
	constexpr const auto & last() const {
		return _data[_size - 1];
	}
	template <size_t C> constexpr bool operator==(const set<T,C> & rhs) const {
		if (_size != rhs._size) return false;
		for (size_t i = 0; i != _size; ++i) {
			if (!(data()[i] == rhs.data()[i])) return false;
		}
		return true;
	}
	template <size_t C> constexpr bool operator<(const set<T,C> & rhs) const {
		for (size_t i = 0; i != _size && i != rhs._size; ++i) {
			if (data()[i] == rhs.data()[i]) continue;
			else if (data()[i] < rhs.data()[i]) return true;
			else return false;
		}
		return _size < rhs._size;
	}
	constexpr auto & operator[](size_t idx) const {
		return data()[idx];
	} 
	constexpr auto & operator[](size_t idx) {
		return data()[idx];
	} 
	template <typename Arg> constexpr auto upper_bound(Arg && obj) {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (!(obj < *it)) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto upper_bound(Arg && obj) const {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (!(obj < *it)) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto lower_bound(Arg && obj) {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (*it < obj) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto lower_bound(Arg && obj) const {
		auto first = begin();
		auto last = end();
		auto it = first;
		size_t count = std::distance(first, last);
		while (count > 0) {
			it = first;
			size_t step = count / 2;
			std::advance(it, step);
			if (*it < obj) {
				first = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return it;
	}
	template <typename Arg> constexpr auto find(Arg && obj) {
		auto it = lower_bound(std::forward<Arg>(obj));
		if (it != end() && *it == obj) return it;
		else return end();
	}
	template <typename Arg> constexpr auto find(Arg && obj) const {
		auto it = lower_bound(std::forward<Arg>(obj));
		if (it != end() && *it == obj) return it;
		else return end();
	}
	template <typename Arg> constexpr auto find_linear(Arg && obj) {
		auto it = begin();
		while (it != end()) {
			if (*it == obj) return it;
			it++;
		}
		return it;
	}
	template <typename Arg> constexpr auto find_linear(Arg && obj) const {
		auto it = begin();
		while (it != end()) {
			if (*it == obj) return it;
			it++;
		}
		return it;
	}
	constexpr std::pair<iterator, bool> insert(T obj) {
		auto it = lower_bound(obj);
		if (it == end()) {
			[[maybe_unused]] auto check = data()[_size];
			*it = obj;
			_size++;
			return {it, true};
		} else if (*it == obj) {
			return {it, false};
		} else {
			[[maybe_unused]] auto check = data()[_size];
			auto out = it;
			while (it != end()) {
				// swap
				auto tmp = std::move(*it);
				*it = std::move(obj);
				obj = std::move(tmp);
				
				it++;
			}
			// swap
			auto tmp = std::move(*it);
			*it = std::move(obj);
			obj = std::move(tmp);
			
			_size++;
			return {out, true};
		}
	}
	constexpr void push_back(T obj) {
		auto it = end();
		*it = obj;
		_size++;
	}
	template <typename Arg> constexpr bool remove(Arg && obj) {
		auto it = lower_bound(std::forward<Arg>(obj));
		if (it != end() && *it == obj) {
			return remove(it);
		} else {
			return false;
		}
	}
	constexpr iterator remove(iterator erase_it) {
		iterator out = erase_it;
		if (erase_it == end()) { 
			return out;
		}
		
		while (erase_it != end()) {
			auto next = erase_it;
			next++;
			if (next != end()) {
				*erase_it = std::move(*next);
			}
			erase_it++;
		}
		_size--;
		return out;
	}
};

}

#endif

#ifndef CTFA__BASIC__TRANSITION__HPP
#define CTFA__BASIC__TRANSITION__HPP

#ifndef CTFA__BASIC__STATE__HPP
#define CTFA__BASIC__STATE__HPP

#ifndef CTFA__CONDITION__HPP
#define CTFA__CONDITION__HPP

#include <string_view>
#ifndef CTFA__UTILITY__HPP
#define CTFA__UTILITY__HPP

#ifdef _MSC_VER
#define CTFA_FORCE_INLINE __forceinline
#define CTFA_FLATTEN
#else
#define CTFA_FORCE_INLINE inline __attribute__((always_inline))
#define CTFA_FLATTEN __attribute__((flatten))
#endif

namespace ctfa {
	struct zero_terminated_string_end_iterator {
		constexpr inline zero_terminated_string_end_iterator() = default;
		constexpr CTFA_FORCE_INLINE bool operator==(const char * ptr) const noexcept {
			return *ptr == '\0';
		} 
		constexpr CTFA_FORCE_INLINE bool operator==(const wchar_t * ptr) const noexcept {
			return *ptr == 0;
		} 
		constexpr CTFA_FORCE_INLINE bool operator!=(const char * ptr) const noexcept {
			return *ptr != '\0';
		} 
		constexpr CTFA_FORCE_INLINE bool operator!=(const wchar_t * ptr) const noexcept {
			return *ptr != 0;
		} 
	};
}

#endif

namespace ctfa {

namespace impl {

struct range {
	char32_t low{};
	char32_t high{};
	CTFA_FORCE_INLINE constexpr bool match(char32_t v) const noexcept {
		return (low <= v) && (v <= high);
	}
	constexpr bool operator<(const range & rhs) const noexcept {
		if (low == rhs.low) {
			return high < rhs.high;
		}
		return low < rhs.low;
	}
	constexpr bool operator==(const range & rhs) const noexcept {
		return low == rhs.low && high == rhs.high;
	}
	constexpr bool operator!=(const range & rhs) const noexcept {
		return low != rhs.low || high != rhs.high;
	}
	template <typename CB> void debug(CB && cb) const {
		if (low == std::numeric_limits<char32_t>::min() && high == std::numeric_limits<char32_t>::max()) {
			cb("anything");
			return;
		}
	
		if (low == std::numeric_limits<char32_t>::min()) cb("MIN");
		else if (low >= 32 && low <= 126) cb('\'',static_cast<char>(low),'\'');
		else cb(low);
		
		if (low != high) {
			cb("..");
			if (high == std::numeric_limits<char32_t>::max()) cb("MAX");
			else if (high >= 32 && high <= 126) cb('\'',static_cast<char>(high),'\'');
			else cb(high);
		}
	}
};

}

struct condition {
	impl::range r;

	constexpr condition() noexcept { }
	
	constexpr condition(const impl::range & r) noexcept: r{r} { }
	
	CTFA_FORCE_INLINE constexpr bool match(char32_t value) const noexcept {
		return r.match(value);
	}
	constexpr bool operator<(const condition & rhs) const noexcept {
		return r < rhs.r;
	}
	constexpr bool operator==(const condition & rhs) const noexcept {
		return r == rhs.r;
	}
	constexpr bool operator!=(const condition & rhs) const noexcept {
		return r != rhs.r;
	}
	template <typename CB> constexpr void debug(CB && cb) const {
		r.debug(cb);
	}
};

namespace matcher {

template <char32_t C> static constexpr auto unit = condition(impl::range{C,C});
template <char32_t A, char32_t B> static constexpr auto range = condition(impl::range{A,B});
static constexpr auto anything = condition(impl::range{std::numeric_limits<char32_t>::min(), std::numeric_limits<char32_t>::max()});

}

}

#endif

namespace ctfa {

struct state {
	int id{-1};
	
	static constexpr int placeholder = -2;
	static constexpr int invalid = -1;
	static constexpr int start = 0;
	
	constexpr bool operator<(const state & rhs) const noexcept {
		return id < rhs.id;
	}
	constexpr bool operator<=(const state & rhs) const noexcept {
		return id <= rhs.id;
	}
	constexpr bool operator==(const state & rhs) const noexcept {
		return id == rhs.id;
	}
	constexpr bool operator!=(const state & rhs) const noexcept {
		return id != rhs.id;
	}
	constexpr state prefix_base(state base) const noexcept {
		return state{id+base.id};
	}
	constexpr state prefix(state base) const noexcept {
		return state{id+base.id};
	}
	constexpr state next() const noexcept {
		return state{id+1};
	}
	constexpr bool is_start() const noexcept {
		return id == start;
	}
};

static constexpr auto start_state = state{state::start};
static constexpr auto invalid_state = state{state::invalid};

}

#endif

namespace ctfa {

struct transition {
	state source;
	state target;
	condition cond;
	constexpr bool operator<(state current) const noexcept {
		return source < current;
	}
	constexpr bool operator==(state current) const noexcept {
		return source == current;
	}
	constexpr bool operator!=(state current) const noexcept {
		return !operator==(current);
	}
	constexpr bool operator<(const transition & rhs) const noexcept {
		if (source == rhs.source) {
			if (cond == rhs.cond) {
				return target < rhs.target;
			}
			return cond < rhs.cond;
		}
		return source < rhs.source;
	}
	constexpr bool operator==(const transition & rhs) const noexcept {
		return source == rhs.source && target == rhs.target && cond == rhs.cond;
	}
	constexpr bool operator!=(const transition & rhs) const noexcept {
		return !operator==(rhs);
	}
	constexpr bool match(char32_t current) const noexcept {
		return cond.match(current);
	}
	constexpr bool is_start() const noexcept {
		return source.is_start();
	}
	constexpr transition prefix(state base) const noexcept {
		return transition{
			source.prefix(base),
			target.prefix(base),
			cond
		};
	}
	constexpr transition prefix_base(state base) const noexcept {
		return transition{
			source.prefix_base(base),
			target.prefix_base(base),
			cond
		};
	}
};

}

#endif

namespace ctfa {

struct transition_count_pair {
	size_t from_start{0};
	size_t other{0};
};

template <size_t Transitions, size_t FinalStates> struct finite_automaton {
	ctfa::set<transition, Transitions> transitions{};
	ctfa::set<state, FinalStates> final_states{};
	
	constexpr finite_automaton() = default;
	constexpr finite_automaton(const ctfa::set<transition, Transitions> & t, const ctfa::set<state, FinalStates> & f): transitions{t}, final_states{f} { }
	
	constexpr bool is_final(state s) const noexcept {
		if (s == invalid_state) return false;
		return final_states.find(s) != final_states.end();
	}

	constexpr auto create_blank() const noexcept {
		return finite_automaton<Transitions, FinalStates>{};
	}
	
	constexpr state next_free_state() const noexcept {
		state highest = invalid_state;
		// I need to iterate because there can be unaccessible state (it's sorted source,target )
		for (const auto & t: transitions) {
			highest = std::max(t.source, highest);
			highest = std::max(t.target, highest);
		}
		for (state s: final_states) {
			highest = std::max(s, highest);
		}
		return highest.next();
	}
	constexpr void add(const transition & t) {
		transitions.insert(t);
	}
	constexpr void mark_final(state s) {
		final_states.insert(s);
	}
	template <size_t T, size_t F> constexpr bool operator==(const finite_automaton<T,F> & rhs) const noexcept {
		return final_states == rhs.final_states && transitions == rhs.transitions;
	}
};

template <const auto & Fa, typename TransitionCB, typename FinalCB> void debug(TransitionCB && tran, FinalCB && final) {
	for (const auto & t: Fa.transitions) {
		tran(t.source, t.target, t.cond, Fa.is_final(t.source));
	}
	for (const auto & f: Fa.final_states) {
		if (Fa.transitions.find(f) == Fa.transitions.end()) final(f);
	}
}

template <typename F> struct filtered_out {
	F fa;
	size_t transitions;
	size_t final_states;
};

template <typename F> filtered_out(const F &, size_t, size_t) -> filtered_out<F>;

}

#endif

#include <algorithm>

namespace ctfa {

struct state_info {
	state s;
	size_t count{0};
	bool is_final{false};
	constexpr operator state() const noexcept {
		return s;
	}
	constexpr bool operator==(const state_info & rhs) const noexcept {
		return s == rhs.s;
	}
	constexpr bool operator<(const state_info & rhs) const noexcept {
		return s < rhs.s;
	}
};

template <const auto & Fa> struct info {
	template <typename CB> static constexpr size_t iterate_over_states(CB && cb) noexcept {
		ctfa::set<state_info, Fa.transitions.size() * 2 + Fa.final_states.size()> known_state;
		for (const auto & t: Fa.transitions) {
			auto pair = known_state.insert(state_info{t.source});
			if (pair.first != known_state.end()) {
				pair.first->count++;
			}
			
			known_state.insert(state_info{t.target});
		}
		for (state s: Fa.final_states) {
			auto pair = known_state.insert(state_info{s});
			if (pair.first != known_state.end()) {
				pair.first->is_final = true;
			}
		}
		for (const state_info & s: known_state) {
			cb(s);
		}
		return known_state.size();
	}
	
	static constexpr size_t max_transitions = []{
		size_t max{0};
		iterate_over_states([&](const auto & state_info){
			max = std::max(state_info.count, max);
		});
		return max;
	}();
	
	static constexpr size_t states = iterate_over_states([](const auto &){});
	
	static constexpr size_t final_states = Fa.final_states.size();
};

}

#endif

namespace ctfa {
	
namespace impl {
	
struct reachable_state {
	state s;
	bool reachable_from_start = false;
	bool reachable_from_final = false;
	constexpr bool operator<(const reachable_state & rhs) const noexcept {
		return s < rhs.s;
	}
	constexpr bool operator==(const reachable_state & rhs) const noexcept {
		return s == rhs.s;
	}
	constexpr bool operator<(state rhs) const noexcept {
		return s < rhs;
	}
	constexpr bool operator==(state rhs) const noexcept {
		return s == rhs;
	}
	constexpr bool mark_reachable_from_start() noexcept {
		bool out = reachable_from_start;
		reachable_from_start = true;
		return !out;
	}
	constexpr bool mark_reachable_from_final() noexcept {
		bool out = reachable_from_final;
		reachable_from_final = true;
		return !out;
	}
	constexpr bool is_needed() const noexcept {
		return reachable_from_start && reachable_from_final;
	}
};

}

template <const auto & Fa> struct remove_unneeded_one {
	static constexpr auto build() {
		ctfa::set<impl::reachable_state, ctfa::info<Fa>::states> known_states;
		
		ctfa::info<Fa>::iterate_over_states([&](const auto & s){
			known_states.push_back(impl::reachable_state{
				state(s), (state(s) == start_state), (s.is_final)
			});
		});
		
		bool changed = true;
		while (changed) {
			changed = false;
			for (const auto & t: Fa.transitions) {
				auto source = known_states.find(t.source);
				auto target = known_states.find(t.target);
				if (source->reachable_from_start) {
					if (target->mark_reachable_from_start()) changed = true;
				}
				if (target->reachable_from_final) {
					if (source->mark_reachable_from_final()) changed = true;
				}
			}
		}
		
		auto out = Fa.create_blank();
		
		for (const auto & t: Fa.transitions) {
			auto source = known_states.find(t.source);
			auto target = known_states.find(t.target);
			if (source->is_needed() && target->is_needed()) {
				out.transitions.push_back(t);  // I know it's sorted
			}
		}
		
		for (state f: Fa.final_states) {
			auto final = known_states.find(f);
			if (final->is_needed()) {
				out.final_states.push_back(f); // I know it's sorted
			}
		}
		
		return out;
	}
	
	static constexpr auto result_unshrinked = build();
	static constexpr auto result = shrink_one<result_unshrinked>::result;
};

}

#endif

#ifndef CTFA__TRANSFORMATION__MINIMIZE__HPP
#define CTFA__TRANSFORMATION__MINIMIZE__HPP

#ifndef CTFA__HELPER__INTERVAL__HPP
#define CTFA__HELPER__INTERVAL__HPP

#include <numeric>

namespace ctfa {

enum class point_type {
	start = 0,
	end = 1
};

constexpr bool operator<(point_type lhs, point_type rhs) {
	return static_cast<int>(lhs) < static_cast<int>(rhs);
}

template <typename Point, typename Feature> struct ipoint {
	Point position;
	point_type type;
	Feature feature;
	unsigned counter;
	constexpr bool operator<(const ipoint & rhs) const {
		if (position == rhs.position) {
			if (type == rhs.type) {
				if (feature == rhs.feature) {
					return counter < rhs.counter;
				} else {
					return feature < rhs.feature;
				}
			} else {
				return type < rhs.type;
			}
		} else {
			return position < rhs.position;
		}
	}
	constexpr bool operator==(const ipoint & rhs) const {
		return position == rhs.position && type == rhs.type && feature == rhs.feature && counter == rhs.counter;
	}
	constexpr bool similar(const ipoint & rhs) const noexcept {
		return position == rhs.position && type == rhs.type;
	}
	constexpr bool fusable(const ipoint & rhs) const noexcept {
		return type == point_type::end && rhs.type == point_type::start && feature == rhs.feature;
	}
	constexpr size_t distance(const ipoint & rhs) const noexcept {
		if (position < rhs.position) {
			return rhs.position - position;
		} else {
			return position - rhs.position;
		}
	}
	constexpr Point get_starting_position() const noexcept {
		if (type == point_type::start) {
			return position;
		} else {
			return position+1;
		}
	}
	constexpr Point get_ending_position() const noexcept {
		if (type == point_type::start) {
			return position-1;
		} else {
			return position;
		}
	}
};

template <size_t NumberOfRanges, typename Point, typename Feature> struct intervals {
	using point = ipoint<Point, Feature>;
	struct feature_with_count {
		Feature feature{};
		size_t count{0};
		constexpr bool operator==(const Feature & rhs) const noexcept {
			return feature == rhs;
		}
		constexpr bool operator<(const Feature & rhs) const noexcept {
			return feature < rhs;
		}
		constexpr bool operator==(const feature_with_count & rhs) const noexcept {
			return feature == rhs.feature;
		}
		constexpr bool operator<(const feature_with_count & rhs) const noexcept {
			return feature < rhs.feature;
		}
		constexpr operator Feature() const noexcept {
			return feature;
		}
	};
	
	ctfa::set<point, NumberOfRanges * 2> buffer;
	unsigned counter{0};
	
	constexpr void insert_range(Point low, Point high, Feature f) {
		buffer.insert(point{low, point_type::start, f, counter++});
		buffer.insert(point{high, point_type::end, f, counter++});
	}
	
	constexpr auto begin() const {
		return buffer.begin();
	}
	
	constexpr auto end() const {
		return buffer.end();
	}
	
	constexpr size_t number_of_ranges() const noexcept {
		return buffer.size() / 2;
	}
	
	constexpr bool merge() {
		bool changed = false;
		
		ctfa::set<feature_with_count, NumberOfRanges> features;
		
		auto add_feature = [&](Feature f) {
			auto pair = features.insert(feature_with_count{f, 1});
			if (!pair.second) {
				// point is not needed, feature was already there
				pair.first->count++;
				changed = true;
				return false;
			} else {
				// point is NEEDED, it adds new feature
				return true;
			}
		};
		
		auto remove_feature = [&](Feature f) {
			auto it = features.find(f);
			if (it->count > 1) {
				it->count--;
				// point is not needed, it doesn't remove anything
				changed = true;
				return false;
			} else {
				features.remove(it);
				// point is NEEDED, it removes feature
				return true;
			}
		};
		
		auto try_fuse_points = [&](auto & it) -> bool {
			auto next = it;
			// search for neighbor point which is positive (I'm negative)
			while (next != buffer.end()) {
				// I can only fuse with neighbor
				if (it->distance(*next) == 0) {
					// skip these
				} else if (it->distance(*next) == 1) {
					// fusable ranges are next to each other
					if (it->fusable(*next)) {
						// and they are negative->positive with same feature
						auto tmp = *it;
						buffer.remove(next);
						changed = true;
						it = buffer.remove(buffer.find(tmp));
						return true;
					}
				} else {
					break;
				}
				
				// try next one
				next++;
			}
			return false;
		};
		
		auto it = buffer.begin();
		
		while (it != buffer.end()) {
			// fuse current point if possible
			// |---a---|
			//          |---a---|
			// should be:
			// |--------a-------|
			
			if (it->type == point_type::end) {
				if (try_fuse_points(it)) continue;
			}
			
			// remove unneeded points:
			// |---a---|
			//      |---a---|
			// should be:
			// |------a-----|
			//
			// or
			// |---a---|
			// |---a---|
			// or
			// |---a---|
			//         |---a---|
			if (it->type == point_type::start) {
				if (!add_feature(it->feature)) {
					it = buffer.remove(it);
					continue;
				}
			} else {
				if (!remove_feature(it->feature)) {
					it = buffer.remove(it);
					continue;
				}
			}
			
			it++;
		}
		
		return changed;
	}
	
	template <typename CB> constexpr size_t split(CB && output) const {
		size_t count = 0;
		
		ctfa::set<Feature, NumberOfRanges> features;
		
		auto it = buffer.begin();
		bool has_last_point = false;
		point last_point{};
		
		while (it != buffer.end()) {
			if (has_last_point) {
				if (last_point.get_starting_position() <= it->get_ending_position()) {
					output(last_point.get_starting_position(), it->get_ending_position(), features);
					count++;
				}
			}
			
			has_last_point = true;
			last_point = *it;
			
			auto first = *it;
			if (it->type == point_type::start) {
				while (it != buffer.end() && it->similar(first)) {
					features.insert(it->feature);
					it++;
				}
			} else {
				while (it != buffer.end() && it->similar(first)) {
					features.remove(it->feature);
					it++;
				}
			}
			if (features.size() == 0) {
				has_last_point = false;
			}
		}
		
		return count;
	}
	template <typename CB> constexpr size_t merge_and_split(CB && output) {
		merge();
		return split(std::forward<CB>(output));
	}
	constexpr size_t merge_and_split() {
		merge();
		return split([](const auto & ...){});
	}
};

template <size_t NumberOfRanges, typename RangeIt, typename CB> constexpr size_t split(const RangeIt & first, const RangeIt & last, CB && cb) {
	intervals<NumberOfRanges, decltype(first->low), decltype(first->feature)> i;
	RangeIt current = first;
	while (current != last) {
		i.insert_range(current->low, current->high, current->feature);
		current++;
	}
	return i.merge_and_split(std::forward<CB>(cb));
}

template <size_t NumberOfRanges, typename RangeIt> constexpr size_t split(const RangeIt & first, const RangeIt & last) {
	intervals<NumberOfRanges, decltype(first->low), decltype(first->feature)> i;
	RangeIt current = first;
	while (current != last) {
		i.insert_range(current->low, current->high, current->feature);
		current++;
	}
	return i.merge_and_split();
}

template <size_t NumberOfRanges, typename Range, typename CB> constexpr size_t split_range(const Range & range, CB && cb) {
	return split<NumberOfRanges>(range.begin(), range.end(), std::forward<CB>(cb));
}

template <size_t NumberOfRanges, typename Range> constexpr size_t split_range(Range && range) {
	return split<NumberOfRanges>(range.begin(), range.end());
}

}

#endif

// TODO better minimizing, based on merge_and_split to groups, not based on different signatures of conditions

namespace ctfa {
	
namespace impl {
	
struct extended_transition {
	transition t;
	int target_index;
	constexpr bool operator<(const extended_transition & rhs) const noexcept {
		return t < rhs.t;
	}
	constexpr bool operator==(const extended_transition & rhs) const noexcept {
		return t == rhs.t;
	}
};
	
template <size_t N> struct transitions_from_state {
	// these are provided 

	state s;
	bool is_final{false};
	int index{0};
	
	// these will be set later
	state group{start_state};
	state next_group{invalid_state};
	bool is_unique{false};
	ctfa::set<extended_transition, N> transitions{};
	ctfa::set<transition, N*2> merged_transitions{};
	
	template <size_t States> constexpr void merge_based_on_group(const ctfa::set<transitions_from_state<N>, States> & table) noexcept {
		intervals<N, char32_t, state> i;
		
		for (const auto & t: transitions) {
			i.insert_range(t.t.cond.r.low, t.t.cond.r.high, table[t.target_index].group);
		}
		
		i.merge_and_split([&](char32_t low, char32_t high, const auto & target_set){
			for (state t: target_set) {
				merged_transitions.insert(transition{s, t, condition(impl::range{low, high})});
			}
		});
	}
	
	constexpr bool operator<(const transitions_from_state & rhs) const noexcept {
		return s < rhs.s;
	}
	constexpr bool operator==(const transitions_from_state & rhs) const noexcept {
		return s == rhs.s;
	}
	constexpr bool operator<(state rhs) const noexcept {
		return s < rhs;
	}
	constexpr bool operator==(state rhs) const noexcept {
		return s == rhs;
	}
};

template <size_t MaxTransitions> constexpr bool is_similar_state(const transitions_from_state<MaxTransitions> & lhs, const transitions_from_state<MaxTransitions> & rhs) {
	// should be in same group
	if (lhs.group != rhs.group) {
		return false;
	}
	if (lhs.is_final != rhs.is_final) {
		return false;
	}
	
	// should have same size
	if (lhs.merged_transitions.size() != rhs.merged_transitions.size()) {
		return false;
	}
	
	for (size_t i = 0; i != lhs.merged_transitions.size(); ++i) {
		// all transitions should have same condition
		if (lhs.merged_transitions[i].cond != rhs.merged_transitions[i].cond) {
			return false;
		}
		// and point to same group
		if (lhs.merged_transitions[i].target != rhs.merged_transitions[i].target) {
			return false;
		}
	}
	
	return true;
}

template <size_t States, size_t MaxTransitions> 
constexpr void mark_group(const ctfa::set<impl::transitions_from_state<MaxTransitions>, States> & table, transitions_from_state<MaxTransitions> & subject, state & available_group) noexcept {
	// find same group and use it's identification or generate new one
	subject.is_unique = true;
	state found_group = available_group;
	
	for (const auto & row: table) {
		if (row.next_group == invalid_state) {
			break;
		}
		
		if (is_similar_state(subject, row)) {
			subject.is_unique = false;
			found_group = row.next_group;
			break;
		}
	}
	
	subject.next_group = found_group;
	// if it's unique, increment state counter
	if (found_group == available_group) available_group = available_group.next();
}

template <size_t States, size_t MaxTransitions> constexpr bool build_groups(ctfa::set<impl::transitions_from_state<MaxTransitions>, States> & table) noexcept {
	// reset next group to default
	for (auto & row: table) {
		row.next_group = invalid_state;
		row.merge_based_on_group(table);
	}
	
	// first group is 0 (start)
	state group_counter = start_state;
	
	// for reach row find similar
	for (auto & row: table) {
		mark_group(table, row, group_counter);
	}
	
	// store next group in group
	bool changed = false;
	
	for (auto & row: table) {
		if (row.group != row.next_group) changed = true;
		row.group = row.next_group;
	}

	return changed;
}

}

template <const auto & Arg> struct minimize_one {
	// before we start minimizing, we need to remove anything unneeded
	static constexpr auto fa = remove_unneeded_one<Arg>::result_unshrinked;
	
	using state_and_transitions = impl::transitions_from_state<fa.transitions.size()>;

	static constexpr auto build() {
		// build known states, split them into groups, return set of groups
		constexpr auto known_states = []{
			ctfa::set<state_and_transitions, ctfa::info<fa>::states> known_states;
		
			// build state table
		
			ctfa::info<fa>::iterate_over_states([&, index = 0] (const auto & s) mutable {
				known_states.push_back({
					state(s), s.is_final, index++
				});
			});
		
			// insert transition with target index in the extended_transition
			for (const auto & t: fa.transitions) {
				auto source = known_states.find(t.source);
				int index = known_states.find(t.target) - known_states.begin();
				source->transitions.push_back(impl::extended_transition{t, index});
			}
		
			// divide into groups until there is no change
			while (build_groups(known_states));
			
			return known_states;
		}();
		
		// precalculate space needed for the output
		constexpr auto transitions = [&]{
			size_t count = 0;
			for (const auto & s: known_states) {
				if (s.is_unique) {
					intervals<fa.transitions.size(), char32_t, state> i;
				
					for (const auto & et: s.transitions) {
						i.insert_range(et.t.cond.r.low, et.t.cond.r.high, known_states[et.target_index].group);
					}
		
					i.merge_and_split([&](char32_t, char32_t, const auto & target_set){
						count+=target_set.size();
					});
				}
			}
			return count;
		}();
		
		// fill output variable
		auto out = finite_automaton<transitions, fa.final_states.size()>();
		
		for (const auto & s: known_states) {
			if (s.is_unique) {
				if (s.is_final) {
					out.final_states.push_back(s.group); // I know it's sorted
				}
				
				intervals<fa.transitions.size(), char32_t, state> i;
				
				auto source = s.group;
				
				for (const auto & et: s.transitions) {
					i.insert_range(et.t.cond.r.low, et.t.cond.r.high, known_states[et.target_index].group);
				}
		
				i.merge_and_split([&](char32_t low, char32_t high, const auto & target_set){
					for (state t: target_set) { // it will happen only once, or it will be nondeterministic
						out.transitions.push_back(transition{source, t, condition(impl::range{low, high})});
					}
				});
			} 
		}
		
		return out;
	}
	
	static constexpr auto result_unshrinked = build();
	static constexpr auto result = shrink_one<result_unshrinked>::result;
};

}

#endif

#ifndef CTFA__TRANSFORMATION__DETERMINIZE2__HPP
#define CTFA__TRANSFORMATION__DETERMINIZE2__HPP

#include <algorithm>

namespace ctfa {

struct resize_info {
	size_t length;
	size_t states;
};

template <size_t States, size_t Length> struct line {
	ctfa::set<state, Length> states;
	bool final{false};
	bool visited{false};
	
	constexpr line() { }
	constexpr line(const ctfa::set<state, Length> & states, bool final): states{states}, final{final} { }
	constexpr line(const line & other) = default;
	template <size_t RhsStates, size_t RhsLength> constexpr line(const line<RhsStates, RhsLength> & other): states{other.states}, final{other.final}, visited{other.visited} { }
	constexpr bool operator<(const line & rhs) const {
		return states < rhs.states;
	}
	constexpr bool operator==(const line & rhs) const {
		return states == rhs.states;
	}
	template <size_t RhsLength> constexpr bool operator<(const ctfa::set<state, RhsLength> & rhs) const {
		return states < rhs;
	}
	template <size_t RhsLength> constexpr bool operator==(const ctfa::set<state, RhsLength> & rhs) const {
		return states == rhs;
	}
};

template <size_t States, size_t Length> struct list_of_states {
	static constexpr size_t max_length = Length;
	
	using line = ctfa::line<States, Length>;
	
	ctfa::set<line, States> _data;
	
	constexpr list_of_states() {
		// do nothing
	}
	template <size_t RhsStates, size_t RhsLength> constexpr list_of_states(const list_of_states<RhsStates, RhsLength> & older) {
		for (const auto & l: older) {
			_data.push_back(line(l));
		}
	}
	constexpr void mark_everything_visited() {
		for (auto & l: _data) {
			l.visited = true;
		}
	}
	template <size_t RhsLength> constexpr bool exists(const ctfa::set<state, RhsLength> & rhs) const {
		return _data.find(rhs) != _data.end();
	}
	constexpr auto begin() const {
		return _data.begin();
	}
	constexpr auto end() const {
		return _data.end();
	}
	template <size_t RhsLength> constexpr auto find(const ctfa::set<state, RhsLength> & rhs) const {
		return _data.find(rhs);
	}
	template <size_t RhsLength> constexpr auto one_state(const ctfa::set<state, RhsLength> & rhs) const {
		return state{int(_data.find(rhs) - _data.begin())};
	}
	constexpr size_t size() const {
		return _data.size();
	}
	constexpr void insert(state s, bool is_final = false) {
		auto pair = _data.insert(line(ctfa::set<state, Length>({s}), is_final));
		if (!pair.second) {
			pair.first->final |= is_final;
		}
	}
	constexpr void insert(ctfa::set<state, Length> s, bool is_final = false) {
		auto pair = _data.insert(line{s, is_final});
		if (!pair.second) {
			pair.first->final |= is_final;
		}
	}
	constexpr bool contains_new_states() const {
		for (const auto & l: _data) {
			if (l.visited == false) return true;
		}
		return false;
	}
};

template <const auto & Fa> struct determinize_one {

	// iterate over all transitions from multi-state (no determinization done, they are from original Fa)
	template <size_t N, typename CB> static constexpr auto iterate_over_multi_state(const ctfa::set<state, N> & states, CB && callback) {
		for (state s: states) {
			auto it = Fa.transitions.lower_bound(s);
			while (it != Fa.transitions.end() && it->source == s) {
				callback(*it);
				it++;
			}
		}
	}

	template <size_t N> static constexpr bool is_multi_state_final(const ctfa::set<state, N> & states) {
		for (state s: states) {
			if (Fa.is_final(s)) return true;
		}
		return false;
	}

	static constexpr auto max_state_count = Fa.transitions.size() * 2 + Fa.final_states.size();
	static constexpr auto max_transition_count = Fa.transitions.size();

	static constexpr auto build_seed() noexcept {
		list_of_states<max_state_count, 1> seed;
	
		for (const auto & t: Fa.transitions) {
			seed.insert(t.source);
			seed.insert(t.target);
		}
	
		for (state s: Fa.final_states) {
			seed.insert(s, true);
		}
	
		return seed;
	}

	static constexpr auto seed = build_seed();

	template <const auto & states> static constexpr auto process() noexcept {
		// calculate how much of new states we need
		constexpr resize_info info = [&]{
			size_t max_length = states.max_length;
			size_t potential_states = states.size();
			for (const auto & st: states) {
				if (st.visited) continue; // ignore visited
			
				intervals<max_transition_count, char32_t, state> i;
				// merge all transitions from state string length
				iterate_over_multi_state(st.states, [&](const transition & t){
					i.insert_range(t.cond.r.low, t.cond.r.high, t.target);
				});
				// determinize state
				i.merge_and_split([&](char32_t, char32_t, const auto & target_set){
					// if new state will be created, resize output, and find maximum of state string length
					if (!states.exists(target_set)) {
						if (target_set.size() > 1) {
							// this is merger
							max_length = std::max(max_length, target_set.size());
							potential_states++;
						}
					}
				});
			}
			return resize_info{max_length, potential_states};
		}();
	
		// fill output
		list_of_states<info.states, info.length> out{states}; // it also set visited in copy constructor
		out.mark_everything_visited();
	
		// add new states
		for (const auto & st: states) {
			if (st.visited) continue; // ignore visited
		
			intervals<max_transition_count, char32_t, state> i;
			// merge all transitions from state string length
			iterate_over_multi_state(st.states, [&](const transition & t){
				i.insert_range(t.cond.r.low, t.cond.r.high, t.target);
			});
			// determinize state
			i.merge_and_split([&](char32_t, char32_t, const auto & target_set){
				// if new state will be created, resize output, and find maximum of state string length
				if (!states.exists(target_set)) {
					if (target_set.size() > 1) {
						// this is merger
						bool is_final = is_multi_state_final(target_set);
						out.insert(target_set, is_final);
					}
				}
			});
		}
	
		return out;
	}
	
	template <const auto & previous> struct recursion_helper {
		static constexpr auto output = process<previous>();
	};
	
	template <const auto & previous = seed> constexpr static auto cycle_build_states() {
		if constexpr (recursion_helper<previous>::output.contains_new_states()) {
			return cycle_build_states<recursion_helper<previous>::output>();
		} else {
			return recursion_helper<previous>::output;
		}
	}
	
	static constexpr auto all_dfa_states = cycle_build_states();
	
	constexpr static auto build() {
		constexpr resize_info info = []{
			size_t final_states{0};
			size_t transitions{0};
			for (const auto & st: all_dfa_states) {
				// calculate final_states
				if (st.final) {
					final_states++;
				}
				
				intervals<max_transition_count, char32_t, state> i;
				// merge all transitions from state string length
				iterate_over_multi_state(st.states, [&](const transition & t){
					i.insert_range(t.cond.r.low, t.cond.r.high, t.target);
				});
				// determinize state
				i.merge_and_split([&](char32_t, char32_t, const auto &){
					transitions++;
				});
			}
			return resize_info{transitions, final_states};
		}(); 
		
		finite_automaton<info.length, info.states> out;
		
		for (const auto & st: all_dfa_states) {
			auto source_state = all_dfa_states.one_state(st.states);
			
			if (st.final) {
				out.mark_final(source_state);
			}
			
			intervals<max_transition_count, char32_t, state> i;
			// merge all transitions from state string length
			iterate_over_multi_state(st.states, [&](const transition & t){
				i.insert_range(t.cond.r.low, t.cond.r.high, t.target);
			});
			// determinize state
			i.merge_and_split([&](char32_t low, char32_t high, const auto & target_set){
				auto target_state = all_dfa_states.one_state(target_set);
				out.add(transition{source_state, target_state, condition(impl::range{low, high})});
			});
		}
		
		return out;
	}
	
	static constexpr auto result = build();
};
	
}

#endif

#ifndef CTFA__TRANSFORMATION__CHARACTER_SET__HPP
#define CTFA__TRANSFORMATION__CHARACTER_SET__HPP

#include <limits>

namespace ctfa {

template <const auto & ... Fa> struct character_set_n {
	static constexpr auto build() {
		constexpr size_t transitions = (Fa.transitions.size() + ... + 0);

		finite_automaton<transitions, 1> output;
		
		// I can do this two push_backs because I know it's already sorted
		auto add = [&](const auto & current){
			for (const auto & t: current.transitions) {
				output.transitions.insert(transition{start_state, state{1}, t.cond}); 
			}
		};
		
		(add(Fa),...);
		
		output.mark_final(state{1});
		
		return output;
	}
	
	static constexpr auto result = build();
};

template <const auto & Fa> struct negative_set_one {
	static constexpr auto build() {
		constexpr auto inter = []{
			intervals<Fa.transitions.size()+1, char32_t, state> i;
		
			for (const auto & t: Fa.transitions) {
				i.insert_range(t.cond.r.low, t.cond.r.high, state{1});
			}
		
			i.insert_range(std::numeric_limits<char32_t>::min(), std::numeric_limits<char32_t>::max(), state{0});
		
			i.merge();
			return i;
		}();
		
		// calculate needed size
		constexpr size_t count = [&]{
			size_t c = 0;
			inter.split([&](char32_t, char32_t, const auto & target_set){
				if (target_set.size() == 1 && target_set[0] == state{0}) {
					c++;
				}
			});
			return c;
		}();
		
		finite_automaton<count, 1> output;
		
		// create transition from everything else
		inter.split([&](char32_t low, char32_t high, const auto & target_set){
			if (target_set.size() == 1 && target_set[0] == state{0}) {
				output.add(transition{start_state, state{1}, condition(impl::range{low, high})});
			}
		});
		
		// state 1 is final
		output.mark_final(state{1});
		
		return output;
	}
	
	static constexpr auto result = build();
};

}

#endif

namespace ctfa {

namespace utility {

template <template <const auto &, const auto &> typename BinaryOp, const auto & ... Fas> struct apply_2;
	
template <template <const auto &, const auto &> typename BinaryOp, const auto & Fa> struct apply_2<BinaryOp, Fa> {
	static constexpr auto & result = Fa;
};

template <template <const auto &, const auto &> typename BinaryOp, const auto & Lhs, const auto & Rhs> struct apply_2<BinaryOp, Lhs, Rhs> {
	static constexpr auto & result = BinaryOp<Lhs, Rhs>::result;
};

template <template <const auto &, const auto &> typename BinaryOp, const auto & Lhs, const auto & Rhs, const auto & ... Fas> struct apply_2<BinaryOp, Lhs, Rhs, Fas...> {
	static constexpr auto & result = apply_2<BinaryOp, BinaryOp<Lhs, Rhs>::result, Fas...>::result;
};
 

}

template <const auto & ... Fas> static constexpr auto concat = utility::apply_2<concat_two, Fas...>::result;

template <const auto & ... Fas> static constexpr auto alternative = utility::apply_2<alternative_two, Fas...>::result;

template <const auto & ... Fas> static constexpr auto plus = plus_one<utility::apply_2<concat_two, Fas...>::result>::result;

template <const auto & ... Fas> static constexpr auto star = star_one<utility::apply_2<concat_two, Fas...>::result>::result;

template <const auto & ... Fas> static constexpr auto optional = optional_one<utility::apply_2<concat_two, Fas...>::result>::result;

template <const auto & ... Fas> static constexpr auto shrink = shrink_one<utility::apply_2<concat_two, Fas...>::result>::result;

template <const auto & ... Fas> static constexpr auto remove_unneeded = remove_unneeded_one<utility::apply_2<concat_two, Fas...>::result>::result;

template <const auto & ... Fas> static constexpr auto minimize = minimize_one<utility::apply_2<concat_two, Fas...>::result>::result;

template <const auto & ... Fas> static constexpr auto determinize = determinize_one<minimize<Fas...>>::result;

template <const auto & ... Fas> static constexpr auto join_character_set = character_set_n<Fas...>::result;

template <const auto & ... Fas> static constexpr auto join_negate_character_set = negative_set_one<character_set_n<Fas...>::result>::result;

}

#endif

#ifndef CTFA__MATCHER__MATCH__HPP
#define CTFA__MATCHER__MATCH__HPP

#ifndef CTFA__UTILITY__HPP
#define CTFA__UTILITY__HPP

#ifdef _MSC_VER
#define CTFA_FORCE_INLINE __forceinline
#define CTFA_FLATTEN
#else
#define CTFA_FORCE_INLINE inline __attribute__((always_inline))
#define CTFA_FLATTEN __attribute__((flatten))
#endif

namespace ctfa {
	struct zero_terminated_string_end_iterator {
		constexpr inline zero_terminated_string_end_iterator() = default;
		constexpr CTFA_FORCE_INLINE bool operator==(const char * ptr) const noexcept {
			return *ptr == '\0';
		} 
		constexpr CTFA_FORCE_INLINE bool operator==(const wchar_t * ptr) const noexcept {
			return *ptr == 0;
		} 
		constexpr CTFA_FORCE_INLINE bool operator!=(const char * ptr) const noexcept {
			return *ptr != '\0';
		} 
		constexpr CTFA_FORCE_INLINE bool operator!=(const wchar_t * ptr) const noexcept {
			return *ptr != 0;
		} 
	};
}

#endif
#include <array>

namespace ctfa {
	
	template <const auto & Dfa> struct table_dispatcher {
		static constexpr auto states() {
			constexpr size_t size = ctfa::info<Dfa>::states;
	
			ctfa::set<state, size> list;
	
			ctfa::info<Dfa>::iterate_over_states([&](state s){
				list.push_back(s);
			});
	
			return list;
		}
		
		static constexpr auto list = states();
		
		template <int transition_index, int current_state, typename Iterator, typename EndIterator> static CTFA_FORCE_INLINE constexpr bool choose_transition(Iterator it, const EndIterator end) noexcept {
			if constexpr (transition_index != Dfa.transitions.size() && Dfa.transitions[transition_index].source.id == current_state) {
				constexpr auto transition = Dfa.transitions[transition_index];
				if (transition.cond.match(*it) && end != it) {
					constexpr size_t index = list.find(transition.target) - list.begin();
					return match_state<Iterator, EndIterator, index>(it+1, end);
					//return run(index, it+1, end);
				} else {
					return choose_transition<transition_index+1, current_state>(it, end);
				}
			} else {
				return false;
			}
		}
	
		template <typename Iterator, typename EndIterator, size_t State> static CTFA_FLATTEN constexpr bool match_state(Iterator it, EndIterator end) noexcept {
			constexpr state current = list[State];
			constexpr auto transition_index = Dfa.transitions.lower_bound(current) - Dfa.transitions.begin();
			
			if constexpr (Dfa.is_final(current)) {
				if (end == it) return true;
			} else {
				if (end == it) return false;
			}
			
			return choose_transition<transition_index, current.id>(it, end);
		} 

		template <typename Iterator, typename EndIterator, size_t... Idx> static constexpr auto build_internal(std::index_sequence<Idx...>) noexcept {
			using function_ptr = bool(*)(Iterator, const EndIterator) noexcept;
			std::array<function_ptr, sizeof...(Idx)> out{{match_state<Iterator, EndIterator, Idx>...}};

			return out;
		}

		template <typename Iterator, typename EndIterator> static constexpr auto CTFA_FORCE_INLINE build() noexcept {
			return build_internal<Iterator, EndIterator>(std::make_index_sequence<list.size()>());
		}

		template <typename Iterator, typename EndIterator> static constexpr auto table = build<Iterator, EndIterator>();

		template <typename Iterator, typename EndIterator> static CTFA_FORCE_INLINE constexpr bool run(size_t s, Iterator it, const EndIterator end) noexcept {
			return table<Iterator, EndIterator>[s](it, end);			
		}
	};

	template <const auto & Dfa> struct dispatcher {
		static constexpr auto states() {
			constexpr size_t size = ctfa::info<Dfa>::states;
		
			ctfa::set<state, size> list;
		
			ctfa::info<Dfa>::iterate_over_states([&](state s){
				list.push_back(s);
			});
		
			return list;
		}
	
		static constexpr auto list = states();
	
		template <int transition_index, int current_state, typename Iterator, typename EndIterator, typename CB> static CTFA_FORCE_INLINE constexpr bool choose_transition(Iterator it, const EndIterator end, CB && cb) noexcept {
			if constexpr (transition_index != Dfa.transitions.size() && Dfa.transitions[transition_index].source.id == current_state) {
				constexpr auto transition = Dfa.transitions[transition_index];
				if constexpr (transition.cond == ctfa::matcher::anything && transition.source == transition.target && Dfa.is_final(state{current_state})) {
					return true;
				} else if (transition.cond.match(*it) && end != it) {
					return cb(transition.target, it, end);
				} else {
					return choose_transition<transition_index+1, current_state>(it, end, std::forward<CB>(cb));
				}
			} else {
				if constexpr (Dfa.is_final(state{current_state})) {
					if (end == it) return true;
				} else {
					if (end == it) return false;
				}
				return false; // if I'm out of options
			}
		}
		
	
		template <int state_index, typename Iterator, typename EndIterator, typename CB> static constexpr bool CTFA_FORCE_INLINE choose_state(state s, Iterator it, const EndIterator end, CB && cb) noexcept {
			if constexpr (state_index != list.size()) {
				constexpr state current = list[state_index];
				if (s == current) {
					constexpr auto transition_index = Dfa.transitions.lower_bound(current) - Dfa.transitions.begin();
					
					return choose_transition<transition_index, current.id>(it, end, std::forward<CB>(cb));
				} else {
					return choose_state<state_index+1>(s, it, end, std::forward<CB>(cb));
				}
			} else {
				// ub
				[[maybe_unused]] auto never_happen = list[list.capacity];
				return false;
			}
		}
	
		template <typename Iterator, typename EndIterator> static CTFA_FORCE_INLINE constexpr bool run(state s, Iterator it, const EndIterator end) noexcept {
			return choose_state<0>(s, it, end, [](state s, Iterator it, const EndIterator end){
				return run(s, it+1, end);
			});
		}
		
	};

	template <const auto & DFa> static constexpr auto match_wrap = ctfa::minimize<ctfa::determinize<DFa>>;

	template <const auto & DFa, typename Range> constexpr bool match(Range && range) noexcept {
		return dispatcher<match_wrap<DFa>>::run(start_state, range.begin(), range.end());
	}

	template <const auto & DFa, typename Ptr> constexpr bool match_ptr(const Ptr * ptr) noexcept {
		return dispatcher<match_wrap<DFa>>::run(start_state, ptr, ctfa::zero_terminated_string_end_iterator());
	}
	
	template <const auto & DFa, typename Range> constexpr bool table_match(Range && range) noexcept {
		return table_dispatcher<match_wrap<DFa>>::run(0, range.begin(), range.end());
	}

	template <const auto & DFa, typename Ptr> constexpr bool table_match_ptr(const Ptr * ptr) noexcept {
		return table_dispatcher<match_wrap<DFa>>::run(0, ptr, ctfa::zero_terminated_string_end_iterator());
	}

	static constexpr auto any_star = ctfa::star<ctfa::block::anything>;

	template <const auto & DFa> static constexpr auto search_wrap = ctfa::minimize<ctfa::determinize<any_star,DFa,any_star>>;

	template <const auto & DFa, typename Range> constexpr bool search(Range && range) noexcept {
		return dispatcher<search_wrap<DFa>>::run(start_state, range.begin(), range.end());
	}

	template <const auto & DFa, typename Ptr> constexpr bool search_ptr(const Ptr * ptr) noexcept {
		return dispatcher<search_wrap<DFa>>::run(start_state, ptr, ctfa::zero_terminated_string_end_iterator());
	}
	
	template <const auto & DFa, typename Range> constexpr bool table_search(Range && range) noexcept {
		return table_dispatcher<search_wrap<DFa>>::run(0, range.begin(), range.end());
	}

	template <const auto & DFa, typename Ptr> constexpr bool table_search_ptr(const Ptr * ptr) noexcept {
		return table_dispatcher<search_wrap<DFa>>::run(0, ptr, ctfa::zero_terminated_string_end_iterator());
	}

}

#endif

#endif

#endif
#include <type_traits>

namespace ctre {
	
struct unsupported_pattern_tag { };

static constexpr inline auto unsupported_pattern = unsupported_pattern_tag{};

// trasnforming the pattern into NFA

template <const auto & Fa = ctfa::block::empty, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<>) noexcept {
	return Fa;
}

// list
template <const auto & Fa = ctfa::block::empty, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctll::list<Content...>, Rest...>) noexcept {
	constexpr auto & inner = translate_nfa(ctll::list<Content...>());
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

// sequence
template <const auto & Fa = ctfa::block::empty, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::sequence<Content...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::concat<translate_nfa(ctll::list<Content>())...>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

// capture without capturing (TODO do the capturing)

template <const auto & Fa = ctfa::block::empty, size_t Id, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::capture<Id, Content...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::concat<translate_nfa(ctll::list<Content...>())>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;

	return translate_nfa<output>(ctll::list<Rest...>());
}

// capture with name
template <const auto & Fa = ctfa::block::empty, size_t Id, typename Name, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::capture_with_name<Id, Name, Content...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::concat<translate_nfa(ctll::list<Content...>())>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;

	return translate_nfa<output>(ctll::list<Rest...>());
}

// optional
template <const auto & Fa = ctfa::block::empty, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::optional<Content...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::optional<translate_nfa(ctll::list<Content>())...>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

// lazy_optional
template <const auto & Fa = ctfa::block::empty, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::lazy_optional<Content...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::optional<translate_nfa(ctll::list<Content>())...>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}
	

// greedy repeat
template <const auto & Fa = ctfa::block::empty, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::plus<Content...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::plus<translate_nfa(ctll::list<Content>())...>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

template <const auto & Fa = ctfa::block::empty, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::star<Content...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::star<translate_nfa(ctll::list<Content>())...>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

// repeat<A,B>
template <size_t Num, typename... Content> struct head_repeat { };
template <size_t Num, typename... Content> struct tail_repeat { };

template <const auto & Fa = ctfa::block::empty, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::head_repeat<0, Content...>, Rest...>) noexcept {
	return translate_nfa<Fa>(ctll::list<Rest...>());
}

template <const auto & Fa = ctfa::block::empty, size_t A, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::head_repeat<A, Content...>, Rest...>) noexcept {
	return translate_nfa<Fa>(ctll::list<Content..., ctre::head_repeat<A-1, Content...>, Rest...>());
}

template <const auto & Fa = ctfa::block::empty, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::tail_repeat<0, Content...>, Rest...>) noexcept {
	return translate_nfa<Fa>(ctll::list<Rest...>());
}

template <const auto & Fa = ctfa::block::empty, size_t B, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::tail_repeat<B, Content...>, Rest...>) noexcept {
	return translate_nfa<Fa>(ctll::list<optional<Content...>, ctre::tail_repeat<B-1, Content...>, Rest...>());
}

template <const auto & Fa = ctfa::block::empty, size_t A, size_t B, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::repeat<A,B, Content...>, Rest...>) noexcept {
	if constexpr (A <= B || B == 0) {
		if constexpr (B != 0) {
			return translate_nfa<Fa>(ctll::list<head_repeat<A,Content...>, tail_repeat<B-A,Content...>, Rest...>());
		} else {
			return translate_nfa<Fa>(ctll::list<head_repeat<A,Content...>, star<Content...>, Rest...>());
		}
	} else {
		return ctfa::block::reject_all;
	}
}

// lazy repeat
template <const auto & Fa = ctfa::block::empty, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::lazy_plus<Content...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::plus<translate_nfa(ctll::list<Content>())...>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

template <const auto & Fa = ctfa::block::empty, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::lazy_star<Content...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::star<translate_nfa(ctll::list<Content>())...>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

// lazy_repeat<A,B>
template <const auto & Fa = ctfa::block::empty, size_t A, size_t B, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::lazy_repeat<A,B, Content...>, Rest...>) noexcept {
	return translate_nfa<Fa>(ctll::list<ctre::repeat<A,B,Content...>, Rest...>());
}

// possesive repeat
template <const auto & Fa = ctfa::block::empty, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::possessive_plus<Content...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::plus<translate_nfa(ctll::list<Content>())...>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

template <const auto & Fa = ctfa::block::empty, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::possessive_star<Content...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::star<translate_nfa(ctll::list<Content>())...>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

// possessive_repeat<A,B>
template <const auto & Fa = ctfa::block::empty, size_t A, size_t B, typename... Content, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::possessive_repeat<A,B, Content...>, Rest...>) noexcept {
	return translate_nfa<Fa>(ctll::list<ctre::repeat<A,B,Content...>, Rest...>());
}

// select
template <const auto & Fa = ctfa::block::empty, typename... Options, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::select<Options...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::alternative<translate_nfa(ctll::list<Options>())...>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

// string
template <const auto & Fa = ctfa::block::empty, auto... Str, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::string<Str...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::block::string<char32_t(Str)...>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

// one character
template <const auto & Fa = ctfa::block::empty, auto N, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::character<N>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::block::unit<char32_t(N)>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

// anything
template <const auto & Fa = ctfa::block::empty, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::any, Rest...>) noexcept {
	constexpr auto & output = ctfa::remove_unneeded<Fa, ctfa::block::anything>;
	
	return translate_nfa<output>(ctll::list<Rest...>());
}

// character sets

struct nfa_set_builder {
	
	//template <typename Head> static constexpr inline auto & item(Head) noexcept {
	//	constexpr auto & current = item(Head())
	//	constexpr auto & output = ctfa::join_character_set<Fa, 
	//}

	template <auto A, auto B> static constexpr inline auto & item(ctre::char_range<A,B>) {
		return ctfa::block::range<char32_t(A), char32_t(B)>;
	}

	template <auto A> static constexpr inline auto & item(ctre::character<A>) {
		return ctfa::block::unit<char32_t(A)>;
	}

	static constexpr inline auto & item(ctre::any) {
		return ctfa::block::anything;
	}

	template <typename... Items> static constexpr inline auto & build(Items...) noexcept {
		return ctfa::join_character_set<item(Items())...>;
	}

	template <typename... Definition> static constexpr inline auto & item(ctre::set<Definition...>) {
		return build(Definition()...);
	}
	
	template <typename... Items> static constexpr inline auto & item(ctre::negative_set<Items...>) {
		return ctfa::join_negate_character_set<item(Items())...>;
	}

};

template <const auto & Fa = ctfa::block::empty, typename... Definition, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::set<Definition...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::determinize<nfa_set_builder::build(Definition()...)>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;

	return translate_nfa<output>(ctll::list<Rest...>());
}

template <const auto & Fa = ctfa::block::empty, typename... Definition, typename... Rest> 
constexpr inline auto & translate_nfa(ctll::list<ctre::negative_set<Definition...>, Rest...>) noexcept {
	constexpr auto & inner = ctfa::determinize<nfa_set_builder::build(ctre::negative_set<Definition...>())>;
	constexpr auto & output = ctfa::remove_unneeded<Fa, inner>;

	return translate_nfa<output>(ctll::list<Rest...>());
}

//template <const auto & Fa = ctfa::block::empty> 
//constexpr inline auto & translate_nfa(...) noexcept {
//	return unsupported_pattern;
//}

// wrapper for DFA

template <typename Pattern> 
constexpr inline auto & translate_dfa(Pattern) noexcept {
	const auto & result = translate_nfa<ctfa::block::empty>(ctll::list<Pattern>());
	using return_type = decltype(result);
	constexpr bool supported_pattern = !std::is_same_v<return_type, unsupported_pattern_tag>;
	static_assert(supported_pattern);
	if constexpr (supported_pattern) return ctfa::minimize<ctfa::determinize<result>>;
	else return ctfa::block::empty;
}

template <typename Pattern> 
constexpr inline auto & search_translate_dfa(Pattern) noexcept {
	const auto & result = translate_nfa<ctfa::block::empty>(ctll::list<Pattern>());
	using return_type = decltype(result);
	constexpr bool supported_pattern = !std::is_same_v<return_type, unsupported_pattern_tag>;
	static_assert(supported_pattern);
	if constexpr (supported_pattern) return ctfa::minimize<ctfa::determinize<ctfa::any_star, ctfa::minimize<ctfa::determinize<result>>, ctfa::any_star>>;
	else return ctfa::block::empty;
}

template <typename Iterator, typename EndIterator, typename Pattern> 
constexpr inline auto fast_match_re(const Iterator begin, const EndIterator end, Pattern pattern) noexcept {
	constexpr auto & dfa = translate_dfa(pattern);
	return ctfa::table_dispatcher<dfa>::run(0, begin, end);
}

template <typename Iterator, typename EndIterator, typename Pattern> 
constexpr inline auto fast_search_re(const Iterator begin, const EndIterator end, Pattern pattern) noexcept {
	constexpr auto & dfa = search_translate_dfa(pattern);
	return ctfa::table_dispatcher<dfa>::run(0, begin, end);
}
	
}

#endif

#include <string_view>
#include <string>

namespace ctre {
	
struct zero_terminated_string_end_iterator {
	constexpr inline zero_terminated_string_end_iterator() = default;
	constexpr CTRE_FORCE_INLINE bool operator==(const char * ptr) const noexcept {
		return *ptr == '\0';
	} 
	constexpr CTRE_FORCE_INLINE bool operator==(const wchar_t * ptr) const noexcept {
		return *ptr == 0;
	} 
	constexpr CTRE_FORCE_INLINE bool operator!=(const char * ptr) const noexcept {
		return *ptr != '\0';
	} 
	constexpr CTRE_FORCE_INLINE bool operator!=(const wchar_t * ptr) const noexcept {
		return *ptr != 0;
	} 
};

template <typename T> class RangeLikeType {
	template <typename Y> static auto test(Y *) -> decltype(std::declval<const Y &>().begin(), std::declval<const Y &>().end(), std::true_type());
	template <typename> static auto test(...) -> std::false_type;
public:
	static inline constexpr bool value = decltype(test<std::remove_reference_t<std::remove_const_t<T>>>( nullptr ))::value;
};

template <typename RE> struct regular_expression {
	template <typename IteratorBegin, typename IteratorEnd> constexpr CTRE_FORCE_INLINE static auto match_2(IteratorBegin begin, IteratorEnd end) noexcept {
		return match_re(begin, end, RE());
	}
	template <typename IteratorBegin, typename IteratorEnd> constexpr CTRE_FORCE_INLINE static auto search_2(IteratorBegin begin, IteratorEnd end) noexcept {
		return search_re(begin, end, RE());
	}
	constexpr CTRE_FORCE_INLINE regular_expression() noexcept { };
	constexpr CTRE_FORCE_INLINE regular_expression(RE) noexcept { };
	template <typename Iterator> constexpr CTRE_FORCE_INLINE static auto match(Iterator begin, Iterator end) noexcept {
		return match_re(begin, end, RE());
	}
	static constexpr CTRE_FORCE_INLINE auto match(const char * s) noexcept {
		return match_2(s, zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto match(const wchar_t * s) noexcept {
		return match_2(s, zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto match(const std::string & s) noexcept {
		return match_2(s.c_str(), zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto match(const std::wstring & s) noexcept {
		return match_2(s.c_str(), zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto match(std::string_view sv) noexcept {
		return match(sv.begin(), sv.end());
	}
	static constexpr CTRE_FORCE_INLINE auto match(std::wstring_view sv) noexcept {
		return match(sv.begin(), sv.end());
	}
	static constexpr CTRE_FORCE_INLINE auto match(std::u16string_view sv) noexcept {
		return match(sv.begin(), sv.end());
	}
	static constexpr CTRE_FORCE_INLINE auto match(std::u32string_view sv) noexcept {
		return match(sv.begin(), sv.end());
	}
	template <typename Range, typename = typename std::enable_if<RangeLikeType<Range>::value>::type> static constexpr CTRE_FORCE_INLINE auto match(Range && range) noexcept {
		return match(std::begin(range), std::end(range));
	}
	template <typename Iterator> constexpr CTRE_FORCE_INLINE static auto search(Iterator begin, Iterator end) noexcept {
		return search_re(begin, end, RE());
	}
	static constexpr CTRE_FORCE_INLINE auto search(const char * s) noexcept {
		return search_2(s, zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto search(const wchar_t * s) noexcept {
		return search_2(s, zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto search(const std::string & s) noexcept {
		return search_2(s.c_str(), zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto search(const std::wstring & s) noexcept {
		return search_2(s.c_str(), zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto search(std::string_view sv) noexcept {
		return search(sv.begin(), sv.end());
	}
	static constexpr CTRE_FORCE_INLINE auto search(std::wstring_view sv) noexcept {
		return search(sv.begin(), sv.end());
	}
	static constexpr CTRE_FORCE_INLINE auto search(std::u16string_view sv) noexcept {
		return search(sv.begin(), sv.end());
	}
	static constexpr CTRE_FORCE_INLINE auto search(std::u32string_view sv) noexcept {
		return search(sv.begin(), sv.end());
	}
	template <typename Range, typename = typename std::enable_if<RangeLikeType<Range>::value>::type> static constexpr CTRE_FORCE_INLINE auto search(Range && range) noexcept {
		return search(std::begin(range), std::end(range));
	}
	
	
	template <typename IteratorBegin, typename IteratorEnd> constexpr CTRE_FORCE_INLINE static auto fast_match_2(IteratorBegin begin, IteratorEnd end) noexcept {
		return fast_match_re(begin, end, RE());
	}
	template <typename IteratorBegin, typename IteratorEnd> constexpr CTRE_FORCE_INLINE static auto fast_search_2(IteratorBegin begin, IteratorEnd end) noexcept {
		return fast_search_re(begin, end, RE());
	}
	
	
	template <typename Iterator> constexpr CTRE_FORCE_INLINE static auto fast_match(Iterator begin, Iterator end) noexcept {
		return fast_match_re(begin, end, RE());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_match(const char * s) noexcept {
		return fast_match_2(s, zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_match(const wchar_t * s) noexcept {
		return fast_match_2(s, zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_match(const std::string & s) noexcept {
		return fast_match_2(s.c_str(), zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_match(const std::wstring & s) noexcept {
		return fast_match_2(s.c_str(), zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_match(std::string_view sv) noexcept {
		return fast_match(sv.begin(), sv.end());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_match(std::wstring_view sv) noexcept {
		return fast_match(sv.begin(), sv.end());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_match(std::u16string_view sv) noexcept {
		return fast_match(sv.begin(), sv.end());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_match(std::u32string_view sv) noexcept {
		return fast_match(sv.begin(), sv.end());
	}
	template <typename Range, typename = typename std::enable_if<RangeLikeType<Range>::value>::type> static constexpr CTRE_FORCE_INLINE auto fast_match(Range && range) noexcept {
		return fast_match(std::begin(range), std::end(range));
	}
	template <typename Iterator> constexpr CTRE_FORCE_INLINE static auto fast_search(Iterator begin, Iterator end) noexcept {
		return fast_search_re(begin, end, RE());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_search(const char * s) noexcept {
		return fast_search_2(s, zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_search(const wchar_t * s) noexcept {
		return fast_search_2(s, zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_search(const std::string & s) noexcept {
		return fast_search_2(s.c_str(), zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_search(const std::wstring & s) noexcept {
		return fast_search_2(s.c_str(), zero_terminated_string_end_iterator());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_search(std::string_view sv) noexcept {
		return fast_search(sv.begin(), sv.end());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_search(std::wstring_view sv) noexcept {
		return fast_search(sv.begin(), sv.end());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_search(std::u16string_view sv) noexcept {
		return fast_search(sv.begin(), sv.end());
	}
	static constexpr CTRE_FORCE_INLINE auto fast_search(std::u32string_view sv) noexcept {
		return fast_search(sv.begin(), sv.end());
	}
	template <typename Range, typename = typename std::enable_if<RangeLikeType<Range>::value>::type> static constexpr CTRE_FORCE_INLINE auto fast_search(Range && range) noexcept {
		return fast_search(std::begin(range), std::end(range));
	}
	
};

template <typename RE> regular_expression(RE) -> regular_expression<RE>;

}

#endif

namespace ctre {

// in C++17 (clang & gcc with gnu extension) we need translate character pack into ctll::fixed_string
// in C++20 we have `class nontype template parameters`

#if !__cpp_nontype_template_parameter_class
template <typename CharT, CharT... input> static inline constexpr auto _fixed_string_reference = ctll::fixed_string< sizeof...(input)>({input...});
#endif	

namespace literals {
	
// clang and GCC <9 supports LITERALS with packs

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgnu-string-literal-operator-template"
#define CTRE_ENABLE_LITERALS
#endif

#ifdef __INTEL_COMPILER
// not enable literals
#elif defined __GNUC__
#if not(__GNUC__ == 9 && __GNUC_MINOR__ == 0 && (__GNUC_PATCHLEVEL__ == 0 || __GNUC_PATCHLEVEL__ == 1))
#define CTRE_ENABLE_LITERALS
#else
#if !__cpp_nontype_template_parameter_class
#define CTRE_ENABLE_LITERALS
#endif
#endif
#endif

#ifdef CTRE_ENABLE_LITERALS
	
// add this when we will have concepts
// requires ctll::parser<ctre::pcre, _fixed_string_reference<CharT, charpack...>, ctre::pcre_actions>::template correct_with<pcre_context<>>

#if !__cpp_nontype_template_parameter_class
template <typename CharT, CharT... charpack> CTRE_FLATTEN constexpr CTRE_FORCE_INLINE auto operator""_ctre() noexcept {
	constexpr auto & _input = _fixed_string_reference<CharT, charpack...>;
#else
template <ctll::fixed_string input> CTRE_FLATTEN constexpr CTRE_FORCE_INLINE auto operator""_ctre() noexcept {
	constexpr auto _input = input; // workaround for GCC 9 bug 88092
#endif
	using tmp = typename ctll::parser<ctre::pcre, _input, ctre::pcre_actions>::template output<pcre_context<>>;
	static_assert(tmp(), "Regular Expression contains syntax error.");
	if constexpr (tmp()) {
		using re = decltype(front(typename tmp::output_type::stack_type()));
		return ctre::regular_expression(re());
	} else {
		return ctre::regular_expression(reject());
	}
}

// this will need to be fixed with C++20
#if !__cpp_nontype_template_parameter_class
template <typename CharT, CharT... charpack> CTRE_FLATTEN constexpr CTRE_FORCE_INLINE auto operator""_ctre_id() noexcept {
	return id<charpack...>();
}
#endif

#endif // CTRE_ENABLE_LITERALS

}

namespace test_literals {
	
#ifdef CTRE_ENABLE_LITERALS

#if !__cpp_nontype_template_parameter_class
template <typename CharT, CharT... charpack> CTRE_FLATTEN constexpr inline auto operator""_ctre_test() noexcept {
	constexpr auto & _input = _fixed_string_reference<CharT, charpack...>;
#else
template <ctll::fixed_string input> CTRE_FLATTEN constexpr inline auto operator""_ctre_test() noexcept {
	constexpr auto _input = input; // workaround for GCC 9 bug 88092
#endif
	return ctll::parser<ctre::pcre, _input>::template correct_with<>;
}

#if !__cpp_nontype_template_parameter_class
template <typename CharT, CharT... charpack> CTRE_FLATTEN constexpr inline auto operator""_ctre_gen() noexcept {
	constexpr auto & _input = _fixed_string_reference<CharT, charpack...>;
#else
template <ctll::fixed_string input> CTRE_FLATTEN constexpr inline auto operator""_ctre_gen() noexcept {
	constexpr auto _input = input; // workaround for GCC 9 bug 88092
#endif
	using tmp = typename ctll::parser<ctre::pcre, _input, ctre::pcre_actions>::template output<pcre_context<>>;
	static_assert(tmp(), "Regular Expression contains syntax error.");
	return typename tmp::output_type::stack_type();
}

#if !__cpp_nontype_template_parameter_class
template <typename CharT, CharT... charpack> CTRE_FLATTEN constexpr CTRE_FORCE_INLINE auto operator""_ctre_syntax() noexcept {
	constexpr auto & _input = _fixed_string_reference<CharT, charpack...>;
#else
template <ctll::fixed_string input> CTRE_FLATTEN constexpr CTRE_FORCE_INLINE auto operator""_ctre_syntax() noexcept {
	constexpr auto _input = input; // workaround for GCC 9 bug 88092
#endif
	return ctll::parser<ctre::pcre, _input, ctre::pcre_actions>::template correct_with<pcre_context<>>;
}

#endif

#ifdef __clang__
#pragma clang diagnostic pop
#endif

} // literals

} // ctre

#endif

#ifndef CTRE_V2__CTRE__FUNCTIONS__HPP
#define CTRE_V2__CTRE__FUNCTIONS__HPP

namespace ctre {

#if !__cpp_nontype_template_parameter_class
// avoiding CTAD limitation in C++17
template <typename CharT, size_t N> class pattern: public ctll::fixed_string<N> {
	using parent = ctll::fixed_string<N>;
public:
	constexpr pattern(const CharT (&input)[N]) noexcept: parent(input) { }
};

template <typename CharT, size_t N> pattern(const CharT (&)[N]) -> pattern<CharT, N>;

// for better examples
template <typename CharT, size_t N> class fixed_string: public ctll::fixed_string<N> {
	using parent = ctll::fixed_string<N>;
public:
	constexpr fixed_string(const CharT (&input)[N]) noexcept: parent(input) { }
};

template <typename CharT, size_t N> fixed_string(const CharT (&)[N]) -> fixed_string<CharT, N>;
#endif

#if __cpp_nontype_template_parameter_class
template <ctll::fixed_string input> CTRE_FLATTEN constexpr CTRE_FORCE_INLINE auto re() noexcept {
constexpr auto _input = input; // workaround for GCC 9 bug 88092
#else
template <const auto &input> CTRE_FLATTEN constexpr CTRE_FORCE_INLINE auto re() noexcept {	
constexpr auto & _input = input; 
#endif
	
	using tmp = typename ctll::parser<ctre::pcre, _input, ctre::pcre_actions>::template output<pcre_context<>>;
	static_assert(tmp(), "Regular Expression contains syntax error.");
	using re = decltype(front(typename tmp::output_type::stack_type()));
	return ctre::regular_expression(re());
}

// in moment when we get C++20 support this will start to work :)

template <typename RE> struct regex_match_t {
	template <typename... Args> CTRE_FORCE_INLINE constexpr auto operator()(Args && ... args) const noexcept {
		auto re_obj = ctre::regular_expression<RE>();
		return re_obj.match(std::forward<Args>(args)...);
	}
};

template <typename RE> struct regex_search_t {
	template <typename... Args> CTRE_FORCE_INLINE constexpr auto operator()(Args && ... args) const noexcept {
		auto re_obj = ctre::regular_expression<RE>();
		return re_obj.search(std::forward<Args>(args)...);
	}
};

template <typename RE> struct fast_regex_match_t {
	template <typename... Args> CTRE_FORCE_INLINE constexpr auto operator()(Args && ... args) const noexcept {
		auto re_obj = ctre::regular_expression<RE>();
		return re_obj.fast_match(std::forward<Args>(args)...);
	}
};

template <typename RE> struct fast_regex_search_t {
	template <typename... Args> CTRE_FORCE_INLINE constexpr auto operator()(Args && ... args) const noexcept {
		auto re_obj = ctre::regular_expression<RE>();
		return re_obj.fast_search(std::forward<Args>(args)...);
	}
};

#if __cpp_nontype_template_parameter_class

template <auto input> struct regex_builder {
	static constexpr auto _input = input;
	using _tmp = typename ctll::parser<ctre::pcre, _input, ctre::pcre_actions>::template output<pcre_context<>>;
	static_assert(_tmp(), "Regular Expression contains syntax error.");
	using type = ctll::conditional<(bool)(_tmp()), decltype(ctll::front(typename _tmp::output_type::stack_type())), ctll::list<reject>>;
};

template <ctll::fixed_string input> static constexpr inline auto match = regex_match_t<typename regex_builder<input>::type>();

template <ctll::fixed_string input> static constexpr inline auto search = regex_search_t<typename regex_builder<input>::type>();

template <ctll::fixed_string input> static constexpr inline auto fast_match = fast_regex_match_t<typename regex_builder<input>::type>();

template <ctll::fixed_string input> static constexpr inline auto fast_search = fast_regex_search_t<typename regex_builder<input>::type>();

#else

template <const auto & input> struct regex_builder {
	using _tmp = typename ctll::parser<ctre::pcre, input, ctre::pcre_actions>::template output<pcre_context<>>;
	static_assert(_tmp(), "Regular Expression contains syntax error.");
	using type = ctll::conditional<(bool)(_tmp()), decltype(ctll::front(typename _tmp::output_type::stack_type())), ctll::list<reject>>;
};

template <const auto &input> static constexpr inline auto match = regex_match_t<typename regex_builder<input>::type>();

template <const auto &input> static constexpr inline auto search = regex_search_t<typename regex_builder<input>::type>();

template <const auto &input> static constexpr inline auto fast_match = fast_regex_match_t<typename regex_builder<input>::type>();

template <const auto &input> static constexpr inline auto fast_search = fast_regex_search_t<typename regex_builder<input>::type>();

#endif

}

#endif

#ifndef CTRE_V2__CTRE__ITERATOR__HPP
#define CTRE_V2__CTRE__ITERATOR__HPP

namespace ctre {

struct regex_end_iterator {
	constexpr regex_end_iterator() noexcept { }
};

template <typename BeginIterator, typename EndIterator, typename RE> struct regex_iterator {
	BeginIterator current;
	const EndIterator end;
	decltype(RE::search_2(std::declval<BeginIterator>(), std::declval<EndIterator>())) current_match;

	constexpr regex_iterator(BeginIterator begin, EndIterator end) noexcept: current{begin}, end{end}, current_match{RE::search_2(current, end)} {
		if (current_match) {
			current = current_match.template get<0>().end();
		}
	}
	constexpr const auto & operator*() const noexcept {
		return current_match;
	}
	constexpr regex_iterator & operator++() noexcept {
		current_match = RE::search_2(current, end);
		if (current_match) {
			current = current_match.template get<0>().end();
		}
		return *this;
	}
	constexpr regex_iterator operator++(int) noexcept {
		auto previous = *this;
		current_match = RE::search_2(current, end);
		if (current_match) {
			current = current_match.template get<0>().end();
		}
		return previous;
	}
};

template <typename BeginIterator, typename EndIterator, typename RE> constexpr bool operator!=(const regex_iterator<BeginIterator, EndIterator, RE> & left, regex_end_iterator) {
	return bool(left.current_match);
}

template <typename BeginIterator, typename EndIterator, typename RE> constexpr bool operator!=(regex_end_iterator, const regex_iterator<BeginIterator, EndIterator, RE> & right) {
	return bool(right.current_match);
}

template <typename BeginIterator, typename EndIterator, typename RE> constexpr auto iterator(BeginIterator begin, EndIterator end, RE) noexcept {
	return regex_iterator<BeginIterator, EndIterator, RE>(begin, end);
}

constexpr auto iterator() noexcept {
	return regex_end_iterator{};
}

template <typename Subject, typename RE> constexpr auto iterator(const Subject & subject, RE re) noexcept {
	return iterator(subject.begin(), subject.end(), re);
}

#if __cpp_nontype_template_parameter_class
template <ctll::fixed_string input, typename BeginIterator, typename EndIterator> CTRE_FLATTEN constexpr CTRE_FORCE_INLINE auto iterator(BeginIterator begin, EndIterator end) noexcept {
	constexpr auto _input = input;
	using tmp = typename ctll::parser<ctre::pcre, _input, ctre::pcre_actions>::template output<pcre_context<>>;
	static_assert(tmp(), "Regular Expression contains syntax error.");
	using re = decltype(front(typename tmp::output_type::stack_type()));
	return iterator(begin, end, re());
}
#endif

#if __cpp_nontype_template_parameter_class
template <ctll::fixed_string input, typename Subject> CTRE_FLATTEN constexpr CTRE_FORCE_INLINE auto iterator(const Subject & subject) noexcept {
	constexpr auto _input = input;
	using tmp = typename ctll::parser<ctre::pcre, _input, ctre::pcre_actions>::template output<pcre_context<>>;
	static_assert(tmp(), "Regular Expression contains syntax error.");
	using re = decltype(front(typename tmp::output_type::stack_type()));
	return iterator(subject.begin(), subject.end(), re());
}
#endif

} // ctre

#endif

#ifndef CTRE_V2__CTRE__RANGE__HPP
#define CTRE_V2__CTRE__RANGE__HPP

namespace ctre {

template <typename BeginIterator, typename EndIterator, typename RE> struct regex_range {
	BeginIterator _begin;
	const EndIterator _end;
	constexpr regex_range(BeginIterator begin, EndIterator end) noexcept: _begin{begin}, _end{end} { }
	
	constexpr auto begin() const noexcept {
		return regex_iterator<BeginIterator, EndIterator, RE>(_begin, _end);
	}
	constexpr auto end() const noexcept {
		return regex_end_iterator{};
	}
};

template <typename BeginIterator, typename EndIterator, typename RE> constexpr auto range(BeginIterator begin, EndIterator end, RE) noexcept {
	return regex_range<BeginIterator, EndIterator, RE>(begin, end);
}

#if __cpp_nontype_template_parameter_class
template <ctll::fixed_string input, typename BeginIterator, typename EndIterator> constexpr auto range(BeginIterator begin, EndIterator end) noexcept {
	constexpr auto _input = input;
	using tmp = typename ctll::parser<ctre::pcre, _input, ctre::pcre_actions>::template output<pcre_context<>>;
	static_assert(tmp(), "Regular Expression contains syntax error.");
	using re = decltype(front(typename tmp::output_type::stack_type()));
	auto re_obj = ctre::regular_expression(re());
	return range(begin, end, re_obj);
}
#endif

template <typename Subject, typename RE> constexpr auto range(const Subject & subject, RE re) noexcept {
	return range(subject.begin(), subject.end(), re);
}

template <typename RE> constexpr auto range(const char * subject, RE re) noexcept {
	return range(subject, zero_terminated_string_end_iterator(), re);
}

#if __cpp_nontype_template_parameter_class
template <ctll::fixed_string input, typename Subject> constexpr auto range(const Subject & subject) noexcept {
	constexpr auto _input = input;
	using tmp = typename ctll::parser<ctre::pcre, _input, ctre::pcre_actions>::template output<pcre_context<>>;
	static_assert(tmp(), "Regular Expression contains syntax error.");
	using re = decltype(front(typename tmp::output_type::stack_type()));
	auto re_obj = ctre::regular_expression(re());
	return range(subject.begin(), subject.end(), re_obj);
}
#else
template <auto & input, typename Subject> constexpr auto range(const Subject & subject) noexcept {
	constexpr auto & _input = input;
	using tmp = typename ctll::parser<ctre::pcre, _input, ctre::pcre_actions>::template output<pcre_context<>>;
	static_assert(tmp(), "Regular Expression contains syntax error.");
	using re = decltype(front(typename tmp::output_type::stack_type()));
	auto re_obj = ctre::regular_expression(re());
	return range(subject.begin(), subject.end(), re_obj);
}
#endif

}

#endif

#ifndef CTRE_V2__CTRE__OPERATORS__HPP
#define CTRE_V2__CTRE__OPERATORS__HPP

template <typename A, typename B> constexpr auto operator|(ctre::regular_expression<A>, ctre::regular_expression<B>) -> ctre::regular_expression<ctre::select<A,B>> {
	return {};
}

template <typename A, typename B> constexpr auto operator>>(ctre::regular_expression<A>, ctre::regular_expression<B>) -> ctre::regular_expression<ctre::sequence<A,B>> {
	return {};
}

#endif

#endif
